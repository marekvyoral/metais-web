/**
 * Generated by orval v6.16.0 üç∫
 * Do not edit manually.
 * MetaIS Enums Repo
 * Api Documentation
 * OpenAPI spec version: 3.0-SNAPSHOT
 */
import { useQuery, useMutation } from '@tanstack/react-query'
import type { UseQueryOptions, UseMutationOptions, QueryFunction, MutationFunction, UseQueryResult, QueryKey } from '@tanstack/react-query'
import { useEnumsRepoSwaggerClient } from '../hooks/useEnumsRepoSwaggerClient'
export type ListValidEnumsWithValueUsingGETParams = {
    /**
     * description
     */
    description: string
    /**
     * value
     */
    value: string
}

/**
 * enumItemApi
 */
export type EnumItemBody = EnumItem

/**
 * enumTypeApi
 */
export type EnumTypeBody = EnumType

export interface EnumTypePreview {
    category?: string
    code?: string
    description?: string
    id?: number
    name?: string
    valid?: boolean
    version?: string
}

export interface EnumTypePreviewList {
    results?: EnumTypePreview[]
}

export interface EnumItem {
    code?: string
    description?: string
    engDescription?: string
    engValue?: string
    id?: number
    orderList?: number
    valid?: boolean
    value?: string
}

export interface EnumType {
    category?: string
    code?: string
    description?: string
    enumItems?: EnumItem[]
    id?: number
    name?: string
    valid?: boolean
}

type AwaitedInput<T> = PromiseLike<T> | T

type Awaited<O> = O extends AwaitedInput<infer T> ? T : never

/**
 * @summary updateEnumItem
 */
export const useUpdateEnumItemUsingPUTHook = () => {
    const updateEnumItemUsingPUT = useEnumsRepoSwaggerClient<void>()

    return (enumItemBody: EnumItemBody) => {
        return updateEnumItemUsingPUT({
            url: `/enumitems/enumitem`,
            method: 'put',
            headers: { 'Content-Type': 'application/json' },
            data: enumItemBody,
        })
    }
}

export const useUpdateEnumItemUsingPUTMutationOptions = <TError = unknown, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<Awaited<ReturnType<ReturnType<typeof useUpdateEnumItemUsingPUTHook>>>, TError, { data: EnumItemBody }, TContext>
}): UseMutationOptions<Awaited<ReturnType<ReturnType<typeof useUpdateEnumItemUsingPUTHook>>>, TError, { data: EnumItemBody }, TContext> => {
    const { mutation: mutationOptions } = options ?? {}

    const updateEnumItemUsingPUT = useUpdateEnumItemUsingPUTHook()

    const mutationFn: MutationFunction<Awaited<ReturnType<ReturnType<typeof useUpdateEnumItemUsingPUTHook>>>, { data: EnumItemBody }> = (props) => {
        const { data } = props ?? {}

        return updateEnumItemUsingPUT(data)
    }

    return { mutationFn, ...mutationOptions }
}

export type UpdateEnumItemUsingPUTMutationResult = NonNullable<Awaited<ReturnType<ReturnType<typeof useUpdateEnumItemUsingPUTHook>>>>
export type UpdateEnumItemUsingPUTMutationBody = EnumItemBody
export type UpdateEnumItemUsingPUTMutationError = unknown

/**
 * @summary updateEnumItem
 */
export const useUpdateEnumItemUsingPUT = <TError = unknown, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<Awaited<ReturnType<ReturnType<typeof useUpdateEnumItemUsingPUTHook>>>, TError, { data: EnumItemBody }, TContext>
}) => {
    const mutationOptions = useUpdateEnumItemUsingPUTMutationOptions(options)

    return useMutation(mutationOptions)
}

/**
 * @summary validEnumItem
 */
export const useValidEnumItemUsingPUTHook = () => {
    const validEnumItemUsingPUT = useEnumsRepoSwaggerClient<void>()

    return (code: string) => {
        return validEnumItemUsingPUT({ url: `/enumitems/enumitem/valid/${code}`, method: 'put' })
    }
}

export const useValidEnumItemUsingPUTMutationOptions = <TError = unknown, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<Awaited<ReturnType<ReturnType<typeof useValidEnumItemUsingPUTHook>>>, TError, { code: string }, TContext>
}): UseMutationOptions<Awaited<ReturnType<ReturnType<typeof useValidEnumItemUsingPUTHook>>>, TError, { code: string }, TContext> => {
    const { mutation: mutationOptions } = options ?? {}

    const validEnumItemUsingPUT = useValidEnumItemUsingPUTHook()

    const mutationFn: MutationFunction<Awaited<ReturnType<ReturnType<typeof useValidEnumItemUsingPUTHook>>>, { code: string }> = (props) => {
        const { code } = props ?? {}

        return validEnumItemUsingPUT(code)
    }

    return { mutationFn, ...mutationOptions }
}

export type ValidEnumItemUsingPUTMutationResult = NonNullable<Awaited<ReturnType<ReturnType<typeof useValidEnumItemUsingPUTHook>>>>

export type ValidEnumItemUsingPUTMutationError = unknown

/**
 * @summary validEnumItem
 */
export const useValidEnumItemUsingPUT = <TError = unknown, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<Awaited<ReturnType<ReturnType<typeof useValidEnumItemUsingPUTHook>>>, TError, { code: string }, TContext>
}) => {
    const mutationOptions = useValidEnumItemUsingPUTMutationOptions(options)

    return useMutation(mutationOptions)
}

/**
 * @summary insertEnumItem
 */
export const useInsertEnumItemUsingPOSTHook = () => {
    const insertEnumItemUsingPOST = useEnumsRepoSwaggerClient<void>()

    return (codeEnumType: string, enumItemBody: EnumItemBody) => {
        return insertEnumItemUsingPOST({
            url: `/enumitems/enumitem/${codeEnumType}`,
            method: 'post',
            headers: { 'Content-Type': 'application/json' },
            data: enumItemBody,
        })
    }
}

export const useInsertEnumItemUsingPOSTMutationOptions = <TError = unknown, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<ReturnType<typeof useInsertEnumItemUsingPOSTHook>>>,
        TError,
        { codeEnumType: string; data: EnumItemBody },
        TContext
    >
}): UseMutationOptions<
    Awaited<ReturnType<ReturnType<typeof useInsertEnumItemUsingPOSTHook>>>,
    TError,
    { codeEnumType: string; data: EnumItemBody },
    TContext
> => {
    const { mutation: mutationOptions } = options ?? {}

    const insertEnumItemUsingPOST = useInsertEnumItemUsingPOSTHook()

    const mutationFn: MutationFunction<
        Awaited<ReturnType<ReturnType<typeof useInsertEnumItemUsingPOSTHook>>>,
        { codeEnumType: string; data: EnumItemBody }
    > = (props) => {
        const { codeEnumType, data } = props ?? {}

        return insertEnumItemUsingPOST(codeEnumType, data)
    }

    return { mutationFn, ...mutationOptions }
}

export type InsertEnumItemUsingPOSTMutationResult = NonNullable<Awaited<ReturnType<ReturnType<typeof useInsertEnumItemUsingPOSTHook>>>>
export type InsertEnumItemUsingPOSTMutationBody = EnumItemBody
export type InsertEnumItemUsingPOSTMutationError = unknown

/**
 * @summary insertEnumItem
 */
export const useInsertEnumItemUsingPOST = <TError = unknown, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<ReturnType<typeof useInsertEnumItemUsingPOSTHook>>>,
        TError,
        { codeEnumType: string; data: EnumItemBody },
        TContext
    >
}) => {
    const mutationOptions = useInsertEnumItemUsingPOSTMutationOptions(options)

    return useMutation(mutationOptions)
}

/**
 * @summary deleteEnumItem
 */
export const useDeleteEnumItemUsingDELETEHook = () => {
    const deleteEnumItemUsingDELETE = useEnumsRepoSwaggerClient<void>()

    return (code: string) => {
        return deleteEnumItemUsingDELETE({ url: `/enumitems/enumitem/${code}`, method: 'delete' })
    }
}

export const useDeleteEnumItemUsingDELETEMutationOptions = <TError = unknown, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<Awaited<ReturnType<ReturnType<typeof useDeleteEnumItemUsingDELETEHook>>>, TError, { code: string }, TContext>
}): UseMutationOptions<Awaited<ReturnType<ReturnType<typeof useDeleteEnumItemUsingDELETEHook>>>, TError, { code: string }, TContext> => {
    const { mutation: mutationOptions } = options ?? {}

    const deleteEnumItemUsingDELETE = useDeleteEnumItemUsingDELETEHook()

    const mutationFn: MutationFunction<Awaited<ReturnType<ReturnType<typeof useDeleteEnumItemUsingDELETEHook>>>, { code: string }> = (props) => {
        const { code } = props ?? {}

        return deleteEnumItemUsingDELETE(code)
    }

    return { mutationFn, ...mutationOptions }
}

export type DeleteEnumItemUsingDELETEMutationResult = NonNullable<Awaited<ReturnType<ReturnType<typeof useDeleteEnumItemUsingDELETEHook>>>>

export type DeleteEnumItemUsingDELETEMutationError = unknown

/**
 * @summary deleteEnumItem
 */
export const useDeleteEnumItemUsingDELETE = <TError = unknown, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<Awaited<ReturnType<ReturnType<typeof useDeleteEnumItemUsingDELETEHook>>>, TError, { code: string }, TContext>
}) => {
    const mutationOptions = useDeleteEnumItemUsingDELETEMutationOptions(options)

    return useMutation(mutationOptions)
}

/**
 * @summary insertEnumType
 */
export const useInsertEnumTypeUsingPOSTHook = () => {
    const insertEnumTypeUsingPOST = useEnumsRepoSwaggerClient<void>()

    return (enumTypeBody: EnumTypeBody) => {
        return insertEnumTypeUsingPOST({ url: `/enums/enum`, method: 'post', headers: { 'Content-Type': 'application/json' }, data: enumTypeBody })
    }
}

export const useInsertEnumTypeUsingPOSTMutationOptions = <TError = unknown, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<Awaited<ReturnType<ReturnType<typeof useInsertEnumTypeUsingPOSTHook>>>, TError, { data: EnumTypeBody }, TContext>
}): UseMutationOptions<Awaited<ReturnType<ReturnType<typeof useInsertEnumTypeUsingPOSTHook>>>, TError, { data: EnumTypeBody }, TContext> => {
    const { mutation: mutationOptions } = options ?? {}

    const insertEnumTypeUsingPOST = useInsertEnumTypeUsingPOSTHook()

    const mutationFn: MutationFunction<Awaited<ReturnType<ReturnType<typeof useInsertEnumTypeUsingPOSTHook>>>, { data: EnumTypeBody }> = (props) => {
        const { data } = props ?? {}

        return insertEnumTypeUsingPOST(data)
    }

    return { mutationFn, ...mutationOptions }
}

export type InsertEnumTypeUsingPOSTMutationResult = NonNullable<Awaited<ReturnType<ReturnType<typeof useInsertEnumTypeUsingPOSTHook>>>>
export type InsertEnumTypeUsingPOSTMutationBody = EnumTypeBody
export type InsertEnumTypeUsingPOSTMutationError = unknown

/**
 * @summary insertEnumType
 */
export const useInsertEnumTypeUsingPOST = <TError = unknown, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<Awaited<ReturnType<ReturnType<typeof useInsertEnumTypeUsingPOSTHook>>>, TError, { data: EnumTypeBody }, TContext>
}) => {
    const mutationOptions = useInsertEnumTypeUsingPOSTMutationOptions(options)

    return useMutation(mutationOptions)
}

/**
 * @summary updateEnumType
 */
export const useUpdateEnumTypeUsingPUTHook = () => {
    const updateEnumTypeUsingPUT = useEnumsRepoSwaggerClient<void>()

    return (enumTypeBody: EnumTypeBody) => {
        return updateEnumTypeUsingPUT({ url: `/enums/enum`, method: 'put', headers: { 'Content-Type': 'application/json' }, data: enumTypeBody })
    }
}

export const useUpdateEnumTypeUsingPUTMutationOptions = <TError = unknown, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<Awaited<ReturnType<ReturnType<typeof useUpdateEnumTypeUsingPUTHook>>>, TError, { data: EnumTypeBody }, TContext>
}): UseMutationOptions<Awaited<ReturnType<ReturnType<typeof useUpdateEnumTypeUsingPUTHook>>>, TError, { data: EnumTypeBody }, TContext> => {
    const { mutation: mutationOptions } = options ?? {}

    const updateEnumTypeUsingPUT = useUpdateEnumTypeUsingPUTHook()

    const mutationFn: MutationFunction<Awaited<ReturnType<ReturnType<typeof useUpdateEnumTypeUsingPUTHook>>>, { data: EnumTypeBody }> = (props) => {
        const { data } = props ?? {}

        return updateEnumTypeUsingPUT(data)
    }

    return { mutationFn, ...mutationOptions }
}

export type UpdateEnumTypeUsingPUTMutationResult = NonNullable<Awaited<ReturnType<ReturnType<typeof useUpdateEnumTypeUsingPUTHook>>>>
export type UpdateEnumTypeUsingPUTMutationBody = EnumTypeBody
export type UpdateEnumTypeUsingPUTMutationError = unknown

/**
 * @summary updateEnumType
 */
export const useUpdateEnumTypeUsingPUT = <TError = unknown, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<Awaited<ReturnType<ReturnType<typeof useUpdateEnumTypeUsingPUTHook>>>, TError, { data: EnumTypeBody }, TContext>
}) => {
    const mutationOptions = useUpdateEnumTypeUsingPUTMutationOptions(options)

    return useMutation(mutationOptions)
}

/**
 * @summary getEnum
 */
export const useGetEnumUsingGETHook = () => {
    const getEnumUsingGET = useEnumsRepoSwaggerClient<EnumType>()

    return (code: string, signal?: AbortSignal) => {
        return getEnumUsingGET({ url: `/enums/enum/all/${code}`, method: 'get', signal })
    }
}

export const getGetEnumUsingGETQueryKey = (code: string) => [`/enums/enum/all/${code}`] as const

export const useGetEnumUsingGETQueryOptions = <TData = Awaited<ReturnType<ReturnType<typeof useGetEnumUsingGETHook>>>, TError = void>(
    code: string,
    options?: { query?: UseQueryOptions<Awaited<ReturnType<ReturnType<typeof useGetEnumUsingGETHook>>>, TError, TData> },
): UseQueryOptions<Awaited<ReturnType<ReturnType<typeof useGetEnumUsingGETHook>>>, TError, TData> & { queryKey: QueryKey } => {
    const { query: queryOptions } = options ?? {}

    const queryKey = queryOptions?.queryKey ?? getGetEnumUsingGETQueryKey(code)

    const getEnumUsingGET = useGetEnumUsingGETHook()

    const queryFn: QueryFunction<Awaited<ReturnType<ReturnType<typeof useGetEnumUsingGETHook>>>> = ({ signal }) => getEnumUsingGET(code, signal)

    return { queryKey, queryFn, enabled: !!code, ...queryOptions }
}

export type GetEnumUsingGETQueryResult = NonNullable<Awaited<ReturnType<ReturnType<typeof useGetEnumUsingGETHook>>>>
export type GetEnumUsingGETQueryError = void

/**
 * @summary getEnum
 */
export const useGetEnumUsingGET = <TData = Awaited<ReturnType<ReturnType<typeof useGetEnumUsingGETHook>>>, TError = void>(
    code: string,
    options?: { query?: UseQueryOptions<Awaited<ReturnType<ReturnType<typeof useGetEnumUsingGETHook>>>, TError, TData> },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
    const queryOptions = useGetEnumUsingGETQueryOptions(code, options)

    const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

    query.queryKey = queryOptions.queryKey

    return query
}

/**
 * @summary getValidEnum
 */
export const useGetValidEnumUsingGETHook = () => {
    const getValidEnumUsingGET = useEnumsRepoSwaggerClient<EnumType>()

    return (code: string, signal?: AbortSignal) => {
        return getValidEnumUsingGET({ url: `/enums/enum/valid/${code}`, method: 'get', signal })
    }
}

export const getGetValidEnumUsingGETQueryKey = (code: string) => [`/enums/enum/valid/${code}`] as const

export const useGetValidEnumUsingGETQueryOptions = <TData = Awaited<ReturnType<ReturnType<typeof useGetValidEnumUsingGETHook>>>, TError = void>(
    code: string,
    options?: { query?: UseQueryOptions<Awaited<ReturnType<ReturnType<typeof useGetValidEnumUsingGETHook>>>, TError, TData> },
): UseQueryOptions<Awaited<ReturnType<ReturnType<typeof useGetValidEnumUsingGETHook>>>, TError, TData> & { queryKey: QueryKey } => {
    const { query: queryOptions } = options ?? {}

    const queryKey = queryOptions?.queryKey ?? getGetValidEnumUsingGETQueryKey(code)

    const getValidEnumUsingGET = useGetValidEnumUsingGETHook()

    const queryFn: QueryFunction<Awaited<ReturnType<ReturnType<typeof useGetValidEnumUsingGETHook>>>> = ({ signal }) =>
        getValidEnumUsingGET(code, signal)

    return { queryKey, queryFn, enabled: !!code, ...queryOptions }
}

export type GetValidEnumUsingGETQueryResult = NonNullable<Awaited<ReturnType<ReturnType<typeof useGetValidEnumUsingGETHook>>>>
export type GetValidEnumUsingGETQueryError = void

/**
 * @summary getValidEnum
 */
export const useGetValidEnumUsingGET = <TData = Awaited<ReturnType<ReturnType<typeof useGetValidEnumUsingGETHook>>>, TError = void>(
    code: string,
    options?: { query?: UseQueryOptions<Awaited<ReturnType<ReturnType<typeof useGetValidEnumUsingGETHook>>>, TError, TData> },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
    const queryOptions = useGetValidEnumUsingGETQueryOptions(code, options)

    const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

    query.queryKey = queryOptions.queryKey

    return query
}

/**
 * @summary validEnumType
 */
export const useValidEnumTypeUsingPUTHook = () => {
    const validEnumTypeUsingPUT = useEnumsRepoSwaggerClient<void>()

    return (code: string) => {
        return validEnumTypeUsingPUT({ url: `/enums/enum/valid/${code}`, method: 'put' })
    }
}

export const useValidEnumTypeUsingPUTMutationOptions = <TError = unknown, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<Awaited<ReturnType<ReturnType<typeof useValidEnumTypeUsingPUTHook>>>, TError, { code: string }, TContext>
}): UseMutationOptions<Awaited<ReturnType<ReturnType<typeof useValidEnumTypeUsingPUTHook>>>, TError, { code: string }, TContext> => {
    const { mutation: mutationOptions } = options ?? {}

    const validEnumTypeUsingPUT = useValidEnumTypeUsingPUTHook()

    const mutationFn: MutationFunction<Awaited<ReturnType<ReturnType<typeof useValidEnumTypeUsingPUTHook>>>, { code: string }> = (props) => {
        const { code } = props ?? {}

        return validEnumTypeUsingPUT(code)
    }

    return { mutationFn, ...mutationOptions }
}

export type ValidEnumTypeUsingPUTMutationResult = NonNullable<Awaited<ReturnType<ReturnType<typeof useValidEnumTypeUsingPUTHook>>>>

export type ValidEnumTypeUsingPUTMutationError = unknown

/**
 * @summary validEnumType
 */
export const useValidEnumTypeUsingPUT = <TError = unknown, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<Awaited<ReturnType<ReturnType<typeof useValidEnumTypeUsingPUTHook>>>, TError, { code: string }, TContext>
}) => {
    const mutationOptions = useValidEnumTypeUsingPUTMutationOptions(options)

    return useMutation(mutationOptions)
}

/**
 * @summary deleteEnumType
 */
export const useDeleteEnumTypeUsingDELETEHook = () => {
    const deleteEnumTypeUsingDELETE = useEnumsRepoSwaggerClient<void>()

    return (code: string) => {
        return deleteEnumTypeUsingDELETE({ url: `/enums/enum/${code}`, method: 'delete' })
    }
}

export const useDeleteEnumTypeUsingDELETEMutationOptions = <TError = unknown, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<Awaited<ReturnType<ReturnType<typeof useDeleteEnumTypeUsingDELETEHook>>>, TError, { code: string }, TContext>
}): UseMutationOptions<Awaited<ReturnType<ReturnType<typeof useDeleteEnumTypeUsingDELETEHook>>>, TError, { code: string }, TContext> => {
    const { mutation: mutationOptions } = options ?? {}

    const deleteEnumTypeUsingDELETE = useDeleteEnumTypeUsingDELETEHook()

    const mutationFn: MutationFunction<Awaited<ReturnType<ReturnType<typeof useDeleteEnumTypeUsingDELETEHook>>>, { code: string }> = (props) => {
        const { code } = props ?? {}

        return deleteEnumTypeUsingDELETE(code)
    }

    return { mutationFn, ...mutationOptions }
}

export type DeleteEnumTypeUsingDELETEMutationResult = NonNullable<Awaited<ReturnType<ReturnType<typeof useDeleteEnumTypeUsingDELETEHook>>>>

export type DeleteEnumTypeUsingDELETEMutationError = unknown

/**
 * @summary deleteEnumType
 */
export const useDeleteEnumTypeUsingDELETE = <TError = unknown, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<Awaited<ReturnType<ReturnType<typeof useDeleteEnumTypeUsingDELETEHook>>>, TError, { code: string }, TContext>
}) => {
    const mutationOptions = useDeleteEnumTypeUsingDELETEMutationOptions(options)

    return useMutation(mutationOptions)
}

/**
 * @summary listEnums
 */
export const useListEnumsUsingGETHook = () => {
    const listEnumsUsingGET = useEnumsRepoSwaggerClient<EnumTypePreviewList>()

    return (signal?: AbortSignal) => {
        return listEnumsUsingGET({ url: `/enums/list`, method: 'get', signal })
    }
}

export const getListEnumsUsingGETQueryKey = () => [`/enums/list`] as const

export const useListEnumsUsingGETQueryOptions = <TData = Awaited<ReturnType<ReturnType<typeof useListEnumsUsingGETHook>>>, TError = void>(options?: {
    query?: UseQueryOptions<Awaited<ReturnType<ReturnType<typeof useListEnumsUsingGETHook>>>, TError, TData>
}): UseQueryOptions<Awaited<ReturnType<ReturnType<typeof useListEnumsUsingGETHook>>>, TError, TData> & { queryKey: QueryKey } => {
    const { query: queryOptions } = options ?? {}

    const queryKey = queryOptions?.queryKey ?? getListEnumsUsingGETQueryKey()

    const listEnumsUsingGET = useListEnumsUsingGETHook()

    const queryFn: QueryFunction<Awaited<ReturnType<ReturnType<typeof useListEnumsUsingGETHook>>>> = ({ signal }) => listEnumsUsingGET(signal)

    return { queryKey, queryFn, ...queryOptions }
}

export type ListEnumsUsingGETQueryResult = NonNullable<Awaited<ReturnType<ReturnType<typeof useListEnumsUsingGETHook>>>>
export type ListEnumsUsingGETQueryError = void

/**
 * @summary listEnums
 */
export const useListEnumsUsingGET = <TData = Awaited<ReturnType<ReturnType<typeof useListEnumsUsingGETHook>>>, TError = void>(options?: {
    query?: UseQueryOptions<Awaited<ReturnType<ReturnType<typeof useListEnumsUsingGETHook>>>, TError, TData>
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
    const queryOptions = useListEnumsUsingGETQueryOptions(options)

    const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

    query.queryKey = queryOptions.queryKey

    return query
}

/**
 * @summary listValidEnums
 */
export const useListValidEnumsUsingGETHook = () => {
    const listValidEnumsUsingGET = useEnumsRepoSwaggerClient<EnumTypePreviewList>()

    return (signal?: AbortSignal) => {
        return listValidEnumsUsingGET({ url: `/enums/list/all`, method: 'get', signal })
    }
}

export const getListValidEnumsUsingGETQueryKey = () => [`/enums/list/all`] as const

export const useListValidEnumsUsingGETQueryOptions = <
    TData = Awaited<ReturnType<ReturnType<typeof useListValidEnumsUsingGETHook>>>,
    TError = void,
>(options?: {
    query?: UseQueryOptions<Awaited<ReturnType<ReturnType<typeof useListValidEnumsUsingGETHook>>>, TError, TData>
}): UseQueryOptions<Awaited<ReturnType<ReturnType<typeof useListValidEnumsUsingGETHook>>>, TError, TData> & { queryKey: QueryKey } => {
    const { query: queryOptions } = options ?? {}

    const queryKey = queryOptions?.queryKey ?? getListValidEnumsUsingGETQueryKey()

    const listValidEnumsUsingGET = useListValidEnumsUsingGETHook()

    const queryFn: QueryFunction<Awaited<ReturnType<ReturnType<typeof useListValidEnumsUsingGETHook>>>> = ({ signal }) =>
        listValidEnumsUsingGET(signal)

    return { queryKey, queryFn, ...queryOptions }
}

export type ListValidEnumsUsingGETQueryResult = NonNullable<Awaited<ReturnType<ReturnType<typeof useListValidEnumsUsingGETHook>>>>
export type ListValidEnumsUsingGETQueryError = void

/**
 * @summary listValidEnums
 */
export const useListValidEnumsUsingGET = <TData = Awaited<ReturnType<ReturnType<typeof useListValidEnumsUsingGETHook>>>, TError = void>(options?: {
    query?: UseQueryOptions<Awaited<ReturnType<ReturnType<typeof useListValidEnumsUsingGETHook>>>, TError, TData>
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
    const queryOptions = useListValidEnumsUsingGETQueryOptions(options)

    const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

    query.queryKey = queryOptions.queryKey

    return query
}

/**
 * @summary listValidEnumsWithValue
 */
export const useListValidEnumsWithValueUsingGETHook = () => {
    const listValidEnumsWithValueUsingGET = useEnumsRepoSwaggerClient<EnumTypePreviewList>()

    return (params: ListValidEnumsWithValueUsingGETParams, signal?: AbortSignal) => {
        return listValidEnumsWithValueUsingGET({ url: `/enums/list/allWithValue`, method: 'get', params, signal })
    }
}

export const getListValidEnumsWithValueUsingGETQueryKey = (params: ListValidEnumsWithValueUsingGETParams) =>
    [`/enums/list/allWithValue`, ...(params ? [params] : [])] as const

export const useListValidEnumsWithValueUsingGETQueryOptions = <
    TData = Awaited<ReturnType<ReturnType<typeof useListValidEnumsWithValueUsingGETHook>>>,
    TError = void,
>(
    params: ListValidEnumsWithValueUsingGETParams,
    options?: { query?: UseQueryOptions<Awaited<ReturnType<ReturnType<typeof useListValidEnumsWithValueUsingGETHook>>>, TError, TData> },
): UseQueryOptions<Awaited<ReturnType<ReturnType<typeof useListValidEnumsWithValueUsingGETHook>>>, TError, TData> & { queryKey: QueryKey } => {
    const { query: queryOptions } = options ?? {}

    const queryKey = queryOptions?.queryKey ?? getListValidEnumsWithValueUsingGETQueryKey(params)

    const listValidEnumsWithValueUsingGET = useListValidEnumsWithValueUsingGETHook()

    const queryFn: QueryFunction<Awaited<ReturnType<ReturnType<typeof useListValidEnumsWithValueUsingGETHook>>>> = ({ signal }) =>
        listValidEnumsWithValueUsingGET(params, signal)

    return { queryKey, queryFn, ...queryOptions }
}

export type ListValidEnumsWithValueUsingGETQueryResult = NonNullable<Awaited<ReturnType<ReturnType<typeof useListValidEnumsWithValueUsingGETHook>>>>
export type ListValidEnumsWithValueUsingGETQueryError = void

/**
 * @summary listValidEnumsWithValue
 */
export const useListValidEnumsWithValueUsingGET = <
    TData = Awaited<ReturnType<ReturnType<typeof useListValidEnumsWithValueUsingGETHook>>>,
    TError = void,
>(
    params: ListValidEnumsWithValueUsingGETParams,
    options?: { query?: UseQueryOptions<Awaited<ReturnType<ReturnType<typeof useListValidEnumsWithValueUsingGETHook>>>, TError, TData> },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
    const queryOptions = useListValidEnumsWithValueUsingGETQueryOptions(params, options)

    const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

    query.queryKey = queryOptions.queryKey

    return query
}

/**
 * @summary listLicenseEnums
 */
export const useListLicenseEnumsUsingGETHook = () => {
    const listLicenseEnumsUsingGET = useEnumsRepoSwaggerClient<EnumTypePreviewList>()

    return (signal?: AbortSignal) => {
        return listLicenseEnumsUsingGET({ url: `/enums/list/license`, method: 'get', signal })
    }
}

export const getListLicenseEnumsUsingGETQueryKey = () => [`/enums/list/license`] as const

export const useListLicenseEnumsUsingGETQueryOptions = <
    TData = Awaited<ReturnType<ReturnType<typeof useListLicenseEnumsUsingGETHook>>>,
    TError = void,
>(options?: {
    query?: UseQueryOptions<Awaited<ReturnType<ReturnType<typeof useListLicenseEnumsUsingGETHook>>>, TError, TData>
}): UseQueryOptions<Awaited<ReturnType<ReturnType<typeof useListLicenseEnumsUsingGETHook>>>, TError, TData> & { queryKey: QueryKey } => {
    const { query: queryOptions } = options ?? {}

    const queryKey = queryOptions?.queryKey ?? getListLicenseEnumsUsingGETQueryKey()

    const listLicenseEnumsUsingGET = useListLicenseEnumsUsingGETHook()

    const queryFn: QueryFunction<Awaited<ReturnType<ReturnType<typeof useListLicenseEnumsUsingGETHook>>>> = ({ signal }) =>
        listLicenseEnumsUsingGET(signal)

    return { queryKey, queryFn, ...queryOptions }
}

export type ListLicenseEnumsUsingGETQueryResult = NonNullable<Awaited<ReturnType<ReturnType<typeof useListLicenseEnumsUsingGETHook>>>>
export type ListLicenseEnumsUsingGETQueryError = void

/**
 * @summary listLicenseEnums
 */
export const useListLicenseEnumsUsingGET = <
    TData = Awaited<ReturnType<ReturnType<typeof useListLicenseEnumsUsingGETHook>>>,
    TError = void,
>(options?: {
    query?: UseQueryOptions<Awaited<ReturnType<ReturnType<typeof useListLicenseEnumsUsingGETHook>>>, TError, TData>
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
    const queryOptions = useListLicenseEnumsUsingGETQueryOptions(options)

    const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

    query.queryKey = queryOptions.queryKey

    return query
}

/**
 * @summary fireJobNow
 */
export const useFireJobNowUsingGETHook = () => {
    const fireJobNowUsingGET = useEnumsRepoSwaggerClient<boolean>()

    return (jobName: string, signal?: AbortSignal) => {
        return fireJobNowUsingGET({ url: `/scheduler/fire/${jobName}`, method: 'get', signal })
    }
}

export const getFireJobNowUsingGETQueryKey = (jobName: string) => [`/scheduler/fire/${jobName}`] as const

export const useFireJobNowUsingGETQueryOptions = <TData = Awaited<ReturnType<ReturnType<typeof useFireJobNowUsingGETHook>>>, TError = void>(
    jobName: string,
    options?: { query?: UseQueryOptions<Awaited<ReturnType<ReturnType<typeof useFireJobNowUsingGETHook>>>, TError, TData> },
): UseQueryOptions<Awaited<ReturnType<ReturnType<typeof useFireJobNowUsingGETHook>>>, TError, TData> & { queryKey: QueryKey } => {
    const { query: queryOptions } = options ?? {}

    const queryKey = queryOptions?.queryKey ?? getFireJobNowUsingGETQueryKey(jobName)

    const fireJobNowUsingGET = useFireJobNowUsingGETHook()

    const queryFn: QueryFunction<Awaited<ReturnType<ReturnType<typeof useFireJobNowUsingGETHook>>>> = ({ signal }) =>
        fireJobNowUsingGET(jobName, signal)

    return { queryKey, queryFn, enabled: !!jobName, ...queryOptions }
}

export type FireJobNowUsingGETQueryResult = NonNullable<Awaited<ReturnType<ReturnType<typeof useFireJobNowUsingGETHook>>>>
export type FireJobNowUsingGETQueryError = void

/**
 * @summary fireJobNow
 */
export const useFireJobNowUsingGET = <TData = Awaited<ReturnType<ReturnType<typeof useFireJobNowUsingGETHook>>>, TError = void>(
    jobName: string,
    options?: { query?: UseQueryOptions<Awaited<ReturnType<ReturnType<typeof useFireJobNowUsingGETHook>>>, TError, TData> },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
    const queryOptions = useFireJobNowUsingGETQueryOptions(jobName, options)

    const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

    query.queryKey = queryOptions.queryKey

    return query
}

/**
 * @summary getJobList
 */
export const useGetJobListUsingGETHook = () => {
    const getJobListUsingGET = useEnumsRepoSwaggerClient<string[]>()

    return (signal?: AbortSignal) => {
        return getJobListUsingGET({ url: `/scheduler/jobList`, method: 'get', signal })
    }
}

export const getGetJobListUsingGETQueryKey = () => [`/scheduler/jobList`] as const

export const useGetJobListUsingGETQueryOptions = <
    TData = Awaited<ReturnType<ReturnType<typeof useGetJobListUsingGETHook>>>,
    TError = void,
>(options?: {
    query?: UseQueryOptions<Awaited<ReturnType<ReturnType<typeof useGetJobListUsingGETHook>>>, TError, TData>
}): UseQueryOptions<Awaited<ReturnType<ReturnType<typeof useGetJobListUsingGETHook>>>, TError, TData> & { queryKey: QueryKey } => {
    const { query: queryOptions } = options ?? {}

    const queryKey = queryOptions?.queryKey ?? getGetJobListUsingGETQueryKey()

    const getJobListUsingGET = useGetJobListUsingGETHook()

    const queryFn: QueryFunction<Awaited<ReturnType<ReturnType<typeof useGetJobListUsingGETHook>>>> = ({ signal }) => getJobListUsingGET(signal)

    return { queryKey, queryFn, ...queryOptions }
}

export type GetJobListUsingGETQueryResult = NonNullable<Awaited<ReturnType<ReturnType<typeof useGetJobListUsingGETHook>>>>
export type GetJobListUsingGETQueryError = void

/**
 * @summary getJobList
 */
export const useGetJobListUsingGET = <TData = Awaited<ReturnType<ReturnType<typeof useGetJobListUsingGETHook>>>, TError = void>(options?: {
    query?: UseQueryOptions<Awaited<ReturnType<ReturnType<typeof useGetJobListUsingGETHook>>>, TError, TData>
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
    const queryOptions = useGetJobListUsingGETQueryOptions(options)

    const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

    query.queryKey = queryOptions.queryKey

    return query
}
