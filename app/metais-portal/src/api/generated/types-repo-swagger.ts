/**
 * Generated by orval v6.16.0 üç∫
 * Do not edit manually.
 * MetaIS Types Repo
 * Api Documentation
 * OpenAPI spec version: 3.0-SNAPSHOT
 */
import { useQuery, useMutation } from '@tanstack/react-query'
import type { UseQueryOptions, UseMutationOptions, QueryFunction, MutationFunction, UseQueryResult, QueryKey } from '@tanstack/react-query'
import { useCustomClient } from '../hooks/use-custom-client'
import type { ErrorType, BodyType } from '../hooks/use-custom-client'
export type ListRelationshipTypesUsingGET1Params = {
    /**
     * roles
     */
    roles: string[]
}

export type DeleteAttributeTextationUsingDELETE1Params = {
    'OAuth2Request.approved'?: boolean
    'OAuth2Request.authorities[0].authority'?: string
    'OAuth2Request.grantType'?: string
    'OAuth2Request.redirectUri'?: string
    'OAuth2Request.refresh'?: boolean
    'OAuth2Request.refreshTokenRequest.grantType'?: string
    'OAuth2Request.resourceIds'?: string[]
    'OAuth2Request.responseTypes'?: string[]
    authenticated?: boolean
    'authorities[0].authority'?: string
    clientOnly?: boolean
    credentials?: { [key: string]: any }
    details?: { [key: string]: any }
    name?: string
    principal?: { [key: string]: any }
    'userAuthentication.authenticated'?: boolean
    'userAuthentication.authorities[0].authority'?: string
    'userAuthentication.credentials'?: { [key: string]: any }
    'userAuthentication.details'?: { [key: string]: any }
    'userAuthentication.principal'?: { [key: string]: any }
}

export type StoreAttributeTextationUsingPUT1Params = {
    'OAuth2Request.approved'?: boolean
    'OAuth2Request.authorities[0].authority'?: string
    'OAuth2Request.grantType'?: string
    'OAuth2Request.redirectUri'?: string
    'OAuth2Request.refresh'?: boolean
    'OAuth2Request.refreshTokenRequest.grantType'?: string
    'OAuth2Request.resourceIds'?: string[]
    'OAuth2Request.responseTypes'?: string[]
    authenticated?: boolean
    'authorities[0].authority'?: string
    clientOnly?: boolean
    credentials?: { [key: string]: any }
    details?: { [key: string]: any }
    name?: string
    principal?: { [key: string]: any }
    'userAuthentication.authenticated'?: boolean
    'userAuthentication.authorities[0].authority'?: string
    'userAuthentication.credentials'?: { [key: string]: any }
    'userAuthentication.details'?: { [key: string]: any }
    'userAuthentication.principal'?: { [key: string]: any }
}

export type UnvalidRelationshipTypeUsingDELETEParams = {
    'OAuth2Request.approved'?: boolean
    'OAuth2Request.authorities[0].authority'?: string
    'OAuth2Request.grantType'?: string
    'OAuth2Request.redirectUri'?: string
    'OAuth2Request.refresh'?: boolean
    'OAuth2Request.refreshTokenRequest.grantType'?: string
    'OAuth2Request.resourceIds'?: string[]
    'OAuth2Request.responseTypes'?: string[]
    authenticated?: boolean
    'authorities[0].authority'?: string
    clientOnly?: boolean
    credentials?: { [key: string]: any }
    details?: { [key: string]: any }
    name?: string
    principal?: { [key: string]: any }
    'userAuthentication.authenticated'?: boolean
    'userAuthentication.authorities[0].authority'?: string
    'userAuthentication.credentials'?: { [key: string]: any }
    'userAuthentication.details'?: { [key: string]: any }
    'userAuthentication.principal'?: { [key: string]: any }
}

export type ValidRelationshipTypeUsingPUTParams = {
    'OAuth2Request.approved'?: boolean
    'OAuth2Request.authorities[0].authority'?: string
    'OAuth2Request.grantType'?: string
    'OAuth2Request.redirectUri'?: string
    'OAuth2Request.refresh'?: boolean
    'OAuth2Request.refreshTokenRequest.grantType'?: string
    'OAuth2Request.resourceIds'?: string[]
    'OAuth2Request.responseTypes'?: string[]
    authenticated?: boolean
    'authorities[0].authority'?: string
    clientOnly?: boolean
    credentials?: { [key: string]: any }
    details?: { [key: string]: any }
    name?: string
    principal?: { [key: string]: any }
    'userAuthentication.authenticated'?: boolean
    'userAuthentication.authorities[0].authority'?: string
    'userAuthentication.credentials'?: { [key: string]: any }
    'userAuthentication.details'?: { [key: string]: any }
    'userAuthentication.principal'?: { [key: string]: any }
}

export type StoreExistRelationshipTypeUsingPUTParams = {
    'OAuth2Request.approved'?: boolean
    'OAuth2Request.authorities[0].authority'?: string
    'OAuth2Request.grantType'?: string
    'OAuth2Request.redirectUri'?: string
    'OAuth2Request.refresh'?: boolean
    'OAuth2Request.refreshTokenRequest.grantType'?: string
    'OAuth2Request.resourceIds'?: string[]
    'OAuth2Request.responseTypes'?: string[]
    authenticated?: boolean
    'authorities[0].authority'?: string
    clientOnly?: boolean
    credentials?: { [key: string]: any }
    details?: { [key: string]: any }
    name?: string
    principal?: { [key: string]: any }
    'userAuthentication.authenticated'?: boolean
    'userAuthentication.authorities[0].authority'?: string
    'userAuthentication.credentials'?: { [key: string]: any }
    'userAuthentication.details'?: { [key: string]: any }
    'userAuthentication.principal'?: { [key: string]: any }
}

export type StoreNewRelationshipTypeUsingPOSTParams = {
    'OAuth2Request.approved'?: boolean
    'OAuth2Request.authorities[0].authority'?: string
    'OAuth2Request.grantType'?: string
    'OAuth2Request.redirectUri'?: string
    'OAuth2Request.refresh'?: boolean
    'OAuth2Request.refreshTokenRequest.grantType'?: string
    'OAuth2Request.resourceIds'?: string[]
    'OAuth2Request.responseTypes'?: string[]
    authenticated?: boolean
    'authorities[0].authority'?: string
    clientOnly?: boolean
    credentials?: { [key: string]: any }
    details?: { [key: string]: any }
    name?: string
    principal?: { [key: string]: any }
    'userAuthentication.authenticated'?: boolean
    'userAuthentication.authorities[0].authority'?: string
    'userAuthentication.credentials'?: { [key: string]: any }
    'userAuthentication.details'?: { [key: string]: any }
    'userAuthentication.principal'?: { [key: string]: any }
}

export type StoreAdminEntityUsingPOST1Params = {
    'OAuth2Request.approved'?: boolean
    'OAuth2Request.authorities[0].authority'?: string
    'OAuth2Request.grantType'?: string
    'OAuth2Request.redirectUri'?: string
    'OAuth2Request.refresh'?: boolean
    'OAuth2Request.refreshTokenRequest.grantType'?: string
    'OAuth2Request.resourceIds'?: string[]
    'OAuth2Request.responseTypes'?: string[]
    authenticated?: boolean
    'authorities[0].authority'?: string
    clientOnly?: boolean
    credentials?: { [key: string]: any }
    details?: { [key: string]: any }
    name?: string
    principal?: { [key: string]: any }
    'userAuthentication.authenticated'?: boolean
    'userAuthentication.authorities[0].authority'?: string
    'userAuthentication.credentials'?: { [key: string]: any }
    'userAuthentication.details'?: { [key: string]: any }
    'userAuthentication.principal'?: { [key: string]: any }
}

export type GetLastCodeUsingGETParams = {
    'OAuth2Request.approved'?: boolean
    'OAuth2Request.authorities[0].authority'?: string
    'OAuth2Request.grantType'?: string
    'OAuth2Request.redirectUri'?: string
    'OAuth2Request.refresh'?: boolean
    'OAuth2Request.refreshTokenRequest.grantType'?: string
    'OAuth2Request.resourceIds'?: string[]
    'OAuth2Request.responseTypes'?: string[]
    authenticated?: boolean
    'authorities[0].authority'?: string
    clientOnly?: boolean
    credentials?: { [key: string]: any }
    details?: { [key: string]: any }
    name?: string
    principal?: { [key: string]: any }
    'userAuthentication.authenticated'?: boolean
    'userAuthentication.authorities[0].authority'?: string
    'userAuthentication.credentials'?: { [key: string]: any }
    'userAuthentication.details'?: { [key: string]: any }
    'userAuthentication.principal'?: { [key: string]: any }
}

export type GenerateCodeAndURLUsingGETParams = {
    'OAuth2Request.approved'?: boolean
    'OAuth2Request.authorities[0].authority'?: string
    'OAuth2Request.grantType'?: string
    'OAuth2Request.redirectUri'?: string
    'OAuth2Request.refresh'?: boolean
    'OAuth2Request.refreshTokenRequest.grantType'?: string
    'OAuth2Request.resourceIds'?: string[]
    'OAuth2Request.responseTypes'?: string[]
    authenticated?: boolean
    'authorities[0].authority'?: string
    clientOnly?: boolean
    /**
     * count
     */
    count: number
    credentials?: { [key: string]: any }
    details?: { [key: string]: any }
    name?: string
    principal?: { [key: string]: any }
    'userAuthentication.authenticated'?: boolean
    'userAuthentication.authorities[0].authority'?: string
    'userAuthentication.credentials'?: { [key: string]: any }
    'userAuthentication.details'?: { [key: string]: any }
    'userAuthentication.principal'?: { [key: string]: any }
}

export type GenerateCodeAndURLUsingGET1Params = {
    'OAuth2Request.approved'?: boolean
    'OAuth2Request.authorities[0].authority'?: string
    'OAuth2Request.grantType'?: string
    'OAuth2Request.redirectUri'?: string
    'OAuth2Request.refresh'?: boolean
    'OAuth2Request.refreshTokenRequest.grantType'?: string
    'OAuth2Request.resourceIds'?: string[]
    'OAuth2Request.responseTypes'?: string[]
    authenticated?: boolean
    'authorities[0].authority'?: string
    clientOnly?: boolean
    credentials?: { [key: string]: any }
    details?: { [key: string]: any }
    name?: string
    principal?: { [key: string]: any }
    'userAuthentication.authenticated'?: boolean
    'userAuthentication.authorities[0].authority'?: string
    'userAuthentication.credentials'?: { [key: string]: any }
    'userAuthentication.details'?: { [key: string]: any }
    'userAuthentication.principal'?: { [key: string]: any }
}

export type StoreAttributeTextationUsingPUTParams = {
    'OAuth2Request.approved'?: boolean
    'OAuth2Request.authorities[0].authority'?: string
    'OAuth2Request.grantType'?: string
    'OAuth2Request.redirectUri'?: string
    'OAuth2Request.refresh'?: boolean
    'OAuth2Request.refreshTokenRequest.grantType'?: string
    'OAuth2Request.resourceIds'?: string[]
    'OAuth2Request.responseTypes'?: string[]
    authenticated?: boolean
    'authorities[0].authority'?: string
    clientOnly?: boolean
    credentials?: { [key: string]: any }
    details?: { [key: string]: any }
    name?: string
    principal?: { [key: string]: any }
    'userAuthentication.authenticated'?: boolean
    'userAuthentication.authorities[0].authority'?: string
    'userAuthentication.credentials'?: { [key: string]: any }
    'userAuthentication.details'?: { [key: string]: any }
    'userAuthentication.principal'?: { [key: string]: any }
}

export type StoreUnvalidUsingDELETE1Params = {
    'OAuth2Request.approved'?: boolean
    'OAuth2Request.authorities[0].authority'?: string
    'OAuth2Request.grantType'?: string
    'OAuth2Request.redirectUri'?: string
    'OAuth2Request.refresh'?: boolean
    'OAuth2Request.refreshTokenRequest.grantType'?: string
    'OAuth2Request.resourceIds'?: string[]
    'OAuth2Request.responseTypes'?: string[]
    authenticated?: boolean
    'authorities[0].authority'?: string
    clientOnly?: boolean
    credentials?: { [key: string]: any }
    details?: { [key: string]: any }
    name?: string
    principal?: { [key: string]: any }
    'userAuthentication.authenticated'?: boolean
    'userAuthentication.authorities[0].authority'?: string
    'userAuthentication.credentials'?: { [key: string]: any }
    'userAuthentication.details'?: { [key: string]: any }
    'userAuthentication.principal'?: { [key: string]: any }
}

export type StoreValidUsingPUT2Params = {
    'OAuth2Request.approved'?: boolean
    'OAuth2Request.authorities[0].authority'?: string
    'OAuth2Request.grantType'?: string
    'OAuth2Request.redirectUri'?: string
    'OAuth2Request.refresh'?: boolean
    'OAuth2Request.refreshTokenRequest.grantType'?: string
    'OAuth2Request.resourceIds'?: string[]
    'OAuth2Request.responseTypes'?: string[]
    authenticated?: boolean
    'authorities[0].authority'?: string
    clientOnly?: boolean
    credentials?: { [key: string]: any }
    details?: { [key: string]: any }
    name?: string
    principal?: { [key: string]: any }
    'userAuthentication.authenticated'?: boolean
    'userAuthentication.authorities[0].authority'?: string
    'userAuthentication.credentials'?: { [key: string]: any }
    'userAuthentication.details'?: { [key: string]: any }
    'userAuthentication.principal'?: { [key: string]: any }
}

export type StoreExistCiTypeUsingPUTParams = {
    'OAuth2Request.approved'?: boolean
    'OAuth2Request.authorities[0].authority'?: string
    'OAuth2Request.grantType'?: string
    'OAuth2Request.redirectUri'?: string
    'OAuth2Request.refresh'?: boolean
    'OAuth2Request.refreshTokenRequest.grantType'?: string
    'OAuth2Request.resourceIds'?: string[]
    'OAuth2Request.responseTypes'?: string[]
    authenticated?: boolean
    'authorities[0].authority'?: string
    clientOnly?: boolean
    credentials?: { [key: string]: any }
    details?: { [key: string]: any }
    name?: string
    principal?: { [key: string]: any }
    'userAuthentication.authenticated'?: boolean
    'userAuthentication.authorities[0].authority'?: string
    'userAuthentication.credentials'?: { [key: string]: any }
    'userAuthentication.details'?: { [key: string]: any }
    'userAuthentication.principal'?: { [key: string]: any }
}

export type StoreNewCiTypeUsingPOSTParams = {
    'OAuth2Request.approved'?: boolean
    'OAuth2Request.authorities[0].authority'?: string
    'OAuth2Request.grantType'?: string
    'OAuth2Request.redirectUri'?: string
    'OAuth2Request.refresh'?: boolean
    'OAuth2Request.refreshTokenRequest.grantType'?: string
    'OAuth2Request.resourceIds'?: string[]
    'OAuth2Request.responseTypes'?: string[]
    authenticated?: boolean
    'authorities[0].authority'?: string
    clientOnly?: boolean
    credentials?: { [key: string]: any }
    details?: { [key: string]: any }
    name?: string
    principal?: { [key: string]: any }
    'userAuthentication.authenticated'?: boolean
    'userAuthentication.authorities[0].authority'?: string
    'userAuthentication.credentials'?: { [key: string]: any }
    'userAuthentication.details'?: { [key: string]: any }
    'userAuthentication.principal'?: { [key: string]: any }
}

export type StoreAdminEntityUsingPOSTParams = {
    'OAuth2Request.approved'?: boolean
    'OAuth2Request.authorities[0].authority'?: string
    'OAuth2Request.grantType'?: string
    'OAuth2Request.redirectUri'?: string
    'OAuth2Request.refresh'?: boolean
    'OAuth2Request.refreshTokenRequest.grantType'?: string
    'OAuth2Request.resourceIds'?: string[]
    'OAuth2Request.responseTypes'?: string[]
    authenticated?: boolean
    'authorities[0].authority'?: string
    clientOnly?: boolean
    credentials?: { [key: string]: any }
    details?: { [key: string]: any }
    name?: string
    principal?: { [key: string]: any }
    'userAuthentication.authenticated'?: boolean
    'userAuthentication.authorities[0].authority'?: string
    'userAuthentication.credentials'?: { [key: string]: any }
    'userAuthentication.details'?: { [key: string]: any }
    'userAuthentication.principal'?: { [key: string]: any }
}

export type StoreExistsCiTypeRelationshipTypeMapUsingPUTParams = {
    'OAuth2Request.approved'?: boolean
    'OAuth2Request.authorities[0].authority'?: string
    'OAuth2Request.grantType'?: string
    'OAuth2Request.redirectUri'?: string
    'OAuth2Request.refresh'?: boolean
    'OAuth2Request.refreshTokenRequest.grantType'?: string
    'OAuth2Request.resourceIds'?: string[]
    'OAuth2Request.responseTypes'?: string[]
    authenticated?: boolean
    'authorities[0].authority'?: string
    clientOnly?: boolean
    credentials?: { [key: string]: any }
    details?: { [key: string]: any }
    name?: string
    principal?: { [key: string]: any }
    'userAuthentication.authenticated'?: boolean
    'userAuthentication.authorities[0].authority'?: string
    'userAuthentication.credentials'?: { [key: string]: any }
    'userAuthentication.details'?: { [key: string]: any }
    'userAuthentication.principal'?: { [key: string]: any }
}

export type StoreNewCiTypeRelationshipTypeMapUsingPOSTParams = {
    'OAuth2Request.approved'?: boolean
    'OAuth2Request.authorities[0].authority'?: string
    'OAuth2Request.grantType'?: string
    'OAuth2Request.redirectUri'?: string
    'OAuth2Request.refresh'?: boolean
    'OAuth2Request.refreshTokenRequest.grantType'?: string
    'OAuth2Request.resourceIds'?: string[]
    'OAuth2Request.responseTypes'?: string[]
    authenticated?: boolean
    'authorities[0].authority'?: string
    clientOnly?: boolean
    credentials?: { [key: string]: any }
    details?: { [key: string]: any }
    name?: string
    principal?: { [key: string]: any }
    'userAuthentication.authenticated'?: boolean
    'userAuthentication.authorities[0].authority'?: string
    'userAuthentication.credentials'?: { [key: string]: any }
    'userAuthentication.details'?: { [key: string]: any }
    'userAuthentication.principal'?: { [key: string]: any }
}

export type StoreUnValidUsingDELETEParams = {
    'OAuth2Request.approved'?: boolean
    'OAuth2Request.authorities[0].authority'?: string
    'OAuth2Request.grantType'?: string
    'OAuth2Request.redirectUri'?: string
    'OAuth2Request.refresh'?: boolean
    'OAuth2Request.refreshTokenRequest.grantType'?: string
    'OAuth2Request.resourceIds'?: string[]
    'OAuth2Request.responseTypes'?: string[]
    authenticated?: boolean
    'authorities[0].authority'?: string
    clientOnly?: boolean
    credentials?: { [key: string]: any }
    details?: { [key: string]: any }
    name?: string
    principal?: { [key: string]: any }
    'userAuthentication.authenticated'?: boolean
    'userAuthentication.authorities[0].authority'?: string
    'userAuthentication.credentials'?: { [key: string]: any }
    'userAuthentication.details'?: { [key: string]: any }
    'userAuthentication.principal'?: { [key: string]: any }
}

export type StoreValidUsingPUT1Params = {
    'OAuth2Request.approved'?: boolean
    'OAuth2Request.authorities[0].authority'?: string
    'OAuth2Request.grantType'?: string
    'OAuth2Request.redirectUri'?: string
    'OAuth2Request.refresh'?: boolean
    'OAuth2Request.refreshTokenRequest.grantType'?: string
    'OAuth2Request.resourceIds'?: string[]
    'OAuth2Request.responseTypes'?: string[]
    authenticated?: boolean
    'authorities[0].authority'?: string
    clientOnly?: boolean
    credentials?: { [key: string]: any }
    details?: { [key: string]: any }
    name?: string
    principal?: { [key: string]: any }
    'userAuthentication.authenticated'?: boolean
    'userAuthentication.authorities[0].authority'?: string
    'userAuthentication.credentials'?: { [key: string]: any }
    'userAuthentication.details'?: { [key: string]: any }
    'userAuthentication.principal'?: { [key: string]: any }
}

export type StoreExistGenericAttrProfileUsingPUTParams = {
    'OAuth2Request.approved'?: boolean
    'OAuth2Request.authorities[0].authority'?: string
    'OAuth2Request.grantType'?: string
    'OAuth2Request.redirectUri'?: string
    'OAuth2Request.refresh'?: boolean
    'OAuth2Request.refreshTokenRequest.grantType'?: string
    'OAuth2Request.resourceIds'?: string[]
    'OAuth2Request.responseTypes'?: string[]
    authenticated?: boolean
    'authorities[0].authority'?: string
    clientOnly?: boolean
    credentials?: { [key: string]: any }
    details?: { [key: string]: any }
    name?: string
    principal?: { [key: string]: any }
    'userAuthentication.authenticated'?: boolean
    'userAuthentication.authorities[0].authority'?: string
    'userAuthentication.credentials'?: { [key: string]: any }
    'userAuthentication.details'?: { [key: string]: any }
    'userAuthentication.principal'?: { [key: string]: any }
}

export type StoreExistAttrProfileUsingPUTParams = {
    'OAuth2Request.approved'?: boolean
    'OAuth2Request.authorities[0].authority'?: string
    'OAuth2Request.grantType'?: string
    'OAuth2Request.redirectUri'?: string
    'OAuth2Request.refresh'?: boolean
    'OAuth2Request.refreshTokenRequest.grantType'?: string
    'OAuth2Request.resourceIds'?: string[]
    'OAuth2Request.responseTypes'?: string[]
    authenticated?: boolean
    'authorities[0].authority'?: string
    clientOnly?: boolean
    credentials?: { [key: string]: any }
    details?: { [key: string]: any }
    name?: string
    principal?: { [key: string]: any }
    'userAuthentication.authenticated'?: boolean
    'userAuthentication.authorities[0].authority'?: string
    'userAuthentication.credentials'?: { [key: string]: any }
    'userAuthentication.details'?: { [key: string]: any }
    'userAuthentication.principal'?: { [key: string]: any }
}

export type StoreNewAttrProfileUsingPOSTParams = {
    'OAuth2Request.approved'?: boolean
    'OAuth2Request.authorities[0].authority'?: string
    'OAuth2Request.grantType'?: string
    'OAuth2Request.redirectUri'?: string
    'OAuth2Request.refresh'?: boolean
    'OAuth2Request.refreshTokenRequest.grantType'?: string
    'OAuth2Request.resourceIds'?: string[]
    'OAuth2Request.responseTypes'?: string[]
    authenticated?: boolean
    'authorities[0].authority'?: string
    clientOnly?: boolean
    credentials?: { [key: string]: any }
    details?: { [key: string]: any }
    name?: string
    principal?: { [key: string]: any }
    'userAuthentication.authenticated'?: boolean
    'userAuthentication.authorities[0].authority'?: string
    'userAuthentication.credentials'?: { [key: string]: any }
    'userAuthentication.details'?: { [key: string]: any }
    'userAuthentication.principal'?: { [key: string]: any }
}

export type StoreUnvalidUsingDELETEParams = {
    'OAuth2Request.approved'?: boolean
    'OAuth2Request.authorities[0].authority'?: string
    'OAuth2Request.grantType'?: string
    'OAuth2Request.redirectUri'?: string
    'OAuth2Request.refresh'?: boolean
    'OAuth2Request.refreshTokenRequest.grantType'?: string
    'OAuth2Request.resourceIds'?: string[]
    'OAuth2Request.responseTypes'?: string[]
    authenticated?: boolean
    'authorities[0].authority'?: string
    clientOnly?: boolean
    credentials?: { [key: string]: any }
    details?: { [key: string]: any }
    name?: string
    principal?: { [key: string]: any }
    'userAuthentication.authenticated'?: boolean
    'userAuthentication.authorities[0].authority'?: string
    'userAuthentication.credentials'?: { [key: string]: any }
    'userAuthentication.details'?: { [key: string]: any }
    'userAuthentication.principal'?: { [key: string]: any }
}

export type StoreValidUsingPUTParams = {
    'OAuth2Request.approved'?: boolean
    'OAuth2Request.authorities[0].authority'?: string
    'OAuth2Request.grantType'?: string
    'OAuth2Request.redirectUri'?: string
    'OAuth2Request.refresh'?: boolean
    'OAuth2Request.refreshTokenRequest.grantType'?: string
    'OAuth2Request.resourceIds'?: string[]
    'OAuth2Request.responseTypes'?: string[]
    authenticated?: boolean
    'authorities[0].authority'?: string
    clientOnly?: boolean
    credentials?: { [key: string]: any }
    details?: { [key: string]: any }
    name?: string
    principal?: { [key: string]: any }
    'userAuthentication.authenticated'?: boolean
    'userAuthentication.authorities[0].authority'?: string
    'userAuthentication.credentials'?: { [key: string]: any }
    'userAuthentication.details'?: { [key: string]: any }
    'userAuthentication.principal'?: { [key: string]: any }
}

export type StoreNewAttributeUsingPOSTParams = {
    'OAuth2Request.approved'?: boolean
    'OAuth2Request.authorities[0].authority'?: string
    'OAuth2Request.grantType'?: string
    'OAuth2Request.redirectUri'?: string
    'OAuth2Request.refresh'?: boolean
    'OAuth2Request.refreshTokenRequest.grantType'?: string
    'OAuth2Request.resourceIds'?: string[]
    'OAuth2Request.responseTypes'?: string[]
    authenticated?: boolean
    'authorities[0].authority'?: string
    clientOnly?: boolean
    credentials?: { [key: string]: any }
    details?: { [key: string]: any }
    name?: string
    principal?: { [key: string]: any }
    'userAuthentication.authenticated'?: boolean
    'userAuthentication.authorities[0].authority'?: string
    'userAuthentication.credentials'?: { [key: string]: any }
    'userAuthentication.details'?: { [key: string]: any }
    'userAuthentication.principal'?: { [key: string]: any }
}

export type StoreExistAttributeUsingPUTParams = {
    'OAuth2Request.approved'?: boolean
    'OAuth2Request.authorities[0].authority'?: string
    'OAuth2Request.grantType'?: string
    'OAuth2Request.redirectUri'?: string
    'OAuth2Request.refresh'?: boolean
    'OAuth2Request.refreshTokenRequest.grantType'?: string
    'OAuth2Request.resourceIds'?: string[]
    'OAuth2Request.responseTypes'?: string[]
    authenticated?: boolean
    'authorities[0].authority'?: string
    clientOnly?: boolean
    credentials?: { [key: string]: any }
    details?: { [key: string]: any }
    name?: string
    principal?: { [key: string]: any }
    'userAuthentication.authenticated'?: boolean
    'userAuthentication.authorities[0].authority'?: string
    'userAuthentication.credentials'?: { [key: string]: any }
    'userAuthentication.details'?: { [key: string]: any }
    'userAuthentication.principal'?: { [key: string]: any }
}

export type StoreInvisibleUsingDELETEParams = {
    'OAuth2Request.approved'?: boolean
    'OAuth2Request.authorities[0].authority'?: string
    'OAuth2Request.grantType'?: string
    'OAuth2Request.redirectUri'?: string
    'OAuth2Request.refresh'?: boolean
    'OAuth2Request.refreshTokenRequest.grantType'?: string
    'OAuth2Request.resourceIds'?: string[]
    'OAuth2Request.responseTypes'?: string[]
    authenticated?: boolean
    'authorities[0].authority'?: string
    clientOnly?: boolean
    credentials?: { [key: string]: any }
    details?: { [key: string]: any }
    name?: string
    principal?: { [key: string]: any }
    'userAuthentication.authenticated'?: boolean
    'userAuthentication.authorities[0].authority'?: string
    'userAuthentication.credentials'?: { [key: string]: any }
    'userAuthentication.details'?: { [key: string]: any }
    'userAuthentication.principal'?: { [key: string]: any }
}

export type StoreVisibleUsingPUTParams = {
    'OAuth2Request.approved'?: boolean
    'OAuth2Request.authorities[0].authority'?: string
    'OAuth2Request.grantType'?: string
    'OAuth2Request.redirectUri'?: string
    'OAuth2Request.refresh'?: boolean
    'OAuth2Request.refreshTokenRequest.grantType'?: string
    'OAuth2Request.resourceIds'?: string[]
    'OAuth2Request.responseTypes'?: string[]
    authenticated?: boolean
    'authorities[0].authority'?: string
    clientOnly?: boolean
    credentials?: { [key: string]: any }
    details?: { [key: string]: any }
    name?: string
    principal?: { [key: string]: any }
    'userAuthentication.authenticated'?: boolean
    'userAuthentication.authorities[0].authority'?: string
    'userAuthentication.credentials'?: { [key: string]: any }
    'userAuthentication.details'?: { [key: string]: any }
    'userAuthentication.principal'?: { [key: string]: any }
}

/**
 * relationshipType
 */
export type RelationshipTypeBody = RelationshipType

/**
 * filter
 */
export type RelationshipTypeFilterBody = RelationshipTypeFilter

/**
 * ciType
 */
export type CiTypeBody = CiType

/**
 * attributeProfile
 */
export type AttributeProfileBody = AttributeProfile

/**
 * attribute
 */
export type AttributeBody = Attribute

/**
 * filter
 */
export type CiTypeFilterBody = CiTypeFilter

/**
 * ciTypeRelationshipTypeMap
 */
export type CiTypeRelationshipTypeMapBody = CiTypeRelationshipTypeMap

/**
 * filter
 */
export type AttributeProfileFilterBody = AttributeProfileFilter

export interface TypesFilter {
    ciTypes?: string[]
    relTypes?: string[]
}

export interface SummarizingCardItemUi {
    attrOrder?: number
    attribute?: Attribute
    description?: string
}

export interface SummarizingCardUi {
    ciType?: string
    description?: string
    showOwner?: boolean
    summarizingCardItems?: SummarizingCardItemUi[]
}

export type RelationshipTypePreviewType = (typeof RelationshipTypePreviewType)[keyof typeof RelationshipTypePreviewType]

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const RelationshipTypePreviewType = {
    system: 'system',
    application: 'application',
    custom: 'custom',
} as const

export interface RelationshipTypePreview {
    category?: string
    description?: string
    engDescription?: string
    engName?: string
    id?: number
    name?: string
    roleList?: string[]
    technicalName?: string
    type?: RelationshipTypePreviewType
    valid?: boolean
}

export interface RelationshipTypePreviewList {
    results?: RelationshipTypePreview[]
}

export interface RightsTypeHolder {
    attributeProfile?: AttributeProfilePreview
    ciType?: CiTypePreviewList
    relationshipsType?: RelationshipTypePreviewList
    role?: string
}

export interface RelationshipTypeFilter {
    role?: string
}

export type RelationshipTypeType = (typeof RelationshipTypeType)[keyof typeof RelationshipTypeType]

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const RelationshipTypeType = {
    system: 'system',
    application: 'application',
    custom: 'custom',
} as const

export interface RelatedCiTypePreviewList {
    cisAsSources?: RelatedCiTypePreview[]
    cisAsTargets?: RelatedCiTypePreview[]
}

export type RelatedCiTypePreviewRelationshipTypeUsageType =
    (typeof RelatedCiTypePreviewRelationshipTypeUsageType)[keyof typeof RelatedCiTypePreviewRelationshipTypeUsageType]

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const RelatedCiTypePreviewRelationshipTypeUsageType = {
    system: 'system',
    application: 'application',
    custom: 'custom',
} as const

export type RelatedCiTypePreviewCiTypeUsageType = (typeof RelatedCiTypePreviewCiTypeUsageType)[keyof typeof RelatedCiTypePreviewCiTypeUsageType]

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const RelatedCiTypePreviewCiTypeUsageType = {
    system: 'system',
    application: 'application',
    custom: 'custom',
} as const

export interface RelatedCiTypePreview {
    ciCategory?: string
    ciRoleList?: string[]
    ciTypeName?: string
    ciTypeTechnicalName?: string
    ciTypeUsageType?: RelatedCiTypePreviewCiTypeUsageType
    ciTypeValid?: boolean
    engCiTypeName?: string
    engRelationshipTypeName?: string
    ownerRelationship?: boolean
    relationshipCategory?: string
    relationshipRoleList?: string[]
    relationshipTypeName?: string
    relationshipTypeTechnicalName?: string
    relationshipTypeUsageType?: RelatedCiTypePreviewRelationshipTypeUsageType
    relationshipTypeValid?: boolean
}

export interface Mandatory {
    processIds?: string[]
    type?: string
}

export interface CiTypesRelationshipTypesList {
    ciTypes?: CiTypePreview[]
    relationshipTypes?: RelationshipTypePreview[]
}

export interface CiTypeRelationshipTypesList {
    asSource?: RelationshipTypePreview[]
    asTarget?: RelationshipTypePreview[]
}

export type CiTypeRelationshipTypeMapCiTypeRoleEnum =
    (typeof CiTypeRelationshipTypeMapCiTypeRoleEnum)[keyof typeof CiTypeRelationshipTypeMapCiTypeRoleEnum]

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CiTypeRelationshipTypeMapCiTypeRoleEnum = {
    SOURCE: 'SOURCE',
    TARGET: 'TARGET',
} as const

export interface CiTypeRelationshipTypeMap {
    ciTypeId?: number
    ciTypeRoleEnum?: CiTypeRelationshipTypeMapCiTypeRoleEnum
    id?: number
    relationshipTypeid?: number
}

export type CiTypePreviewType = (typeof CiTypePreviewType)[keyof typeof CiTypePreviewType]

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CiTypePreviewType = {
    system: 'system',
    application: 'application',
    custom: 'custom',
} as const

export interface CiTypeFilter {
    role?: string
    roles?: string[]
}

export type CiTypeType = (typeof CiTypeType)[keyof typeof CiTypeType]

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CiTypeType = {
    system: 'system',
    application: 'application',
    custom: 'custom',
} as const

export interface CiType {
    attributeProfiles?: AttributeProfile[]
    attributes?: Attribute[]
    category?: string
    codePrefix?: string
    color?: string
    description?: string
    engName?: string
    id?: number
    name?: string
    ownerRelation?: string
    relationshipTypes?: CiTypeRelationshipTypesList
    roleList?: string[]
    technicalName?: string
    type?: CiTypeType
    uriPrefix?: string
    valid?: boolean
}

export interface CiCode {
    cicode?: string
    ciurl?: string
}

export interface Cardinality {
    max?: number
    min?: number
}

export interface AttributeProfilePreview {
    attributeProfileList?: AttributeProfile[]
}

export interface AttributeProfileFilter {
    role?: string
}

export type AttributeProfileType = (typeof AttributeProfileType)[keyof typeof AttributeProfileType]

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const AttributeProfileType = {
    system: 'system',
    application: 'application',
    custom: 'custom',
} as const

export interface AttributeProfile {
    attributes?: Attribute[]
    description?: string
    engDescription?: string
    id?: number
    isGeneric?: boolean
    name?: string
    roleList?: string[]
    technicalName?: string
    type?: AttributeProfileType
    valid?: boolean
}

export interface CiTypePreview {
    attributeProfiles?: AttributeProfile[]
    attributes?: Attribute[]
    category?: string
    codePrefix?: string
    color?: string
    description?: string
    engName?: string
    id?: number
    name?: string
    ownerRelation?: string
    roleList?: string[]
    roles?: string
    technicalName?: string
    type?: CiTypePreviewType
    uriPrefix?: string
    valid?: boolean
}

export interface RelationshipType {
    attributeProfiles?: AttributeProfile[]
    attributes?: Attribute[]
    category?: string
    color?: string
    description?: string
    engDescription?: string
    engName?: string
    id?: number
    name?: string
    roleList?: string[]
    sourceCardinality?: Cardinality
    sources?: CiTypePreview[]
    targetCardinality?: Cardinality
    targets?: CiTypePreview[]
    technicalName?: string
    type?: RelationshipTypeType
    valid?: boolean
}

export interface CiTypePreviewList {
    results?: CiTypePreview[]
}

export type AttributeConstraintRegexAllOf = {
    id?: number
    regex?: string
    type?: string
}

export type AttributeConstraintIntervalAllOf = {
    id?: number
    maxValue?: number
    minValue?: number
    type?: string
}

export type AttributeConstraintInterval = AttributeConstraint & AttributeConstraintIntervalAllOf

export type AttributeConstraintEnumAllOf = {
    enumCode?: string
    id?: number
    type?: string
}

export interface AttributeConstraint {
    id?: number
    type?: string
}

export type AttributeConstraintRegex = AttributeConstraint & AttributeConstraintRegexAllOf

export type AttributeConstraintEnum = AttributeConstraint & AttributeConstraintEnumAllOf

export type AttributeAttributeTypeEnum = (typeof AttributeAttributeTypeEnum)[keyof typeof AttributeAttributeTypeEnum]

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const AttributeAttributeTypeEnum = {
    BOOLEAN: 'BOOLEAN',
    BYTE: 'BYTE',
    SHORT: 'SHORT',
    INTEGER: 'INTEGER',
    LONG: 'LONG',
    FLOAT: 'FLOAT',
    DOUBLE: 'DOUBLE',
    CHARACTER: 'CHARACTER',
    STRING: 'STRING',
    DATE: 'DATE',
    STRING_PAIR: 'STRING_PAIR',
    IMAGE: 'IMAGE',
} as const

export interface Attribute {
    array?: boolean
    attributeTypeEnum?: AttributeAttributeTypeEnum
    constraints?: AttributeConstraint[]
    defaultValue?: string
    description?: string
    displayAs?: string
    engDescription?: string
    engName?: string
    id?: number
    invisible?: boolean
    mandatory?: Mandatory
    name?: string
    order?: number
    readOnly?: boolean
    technicalName?: string
    type?: string
    units?: string
    valid?: boolean
}

type AwaitedInput<T> = PromiseLike<T> | T

type Awaited<O> = O extends AwaitedInput<infer T> ? T : never

/**
 * @summary storeVisible
 */
export const useStoreVisibleUsingPUTHook = () => {
    const storeVisibleUsingPUT = useCustomClient<void>()

    return (attrProfileTechnicalName: string, technicalName: string, params?: StoreVisibleUsingPUTParams) => {
        return storeVisibleUsingPUT({ url: `/attributes/attribute/invisible/${attrProfileTechnicalName}/${technicalName}`, method: 'put', params })
    }
}

export const useStoreVisibleUsingPUTMutationOptions = <TError = ErrorType<unknown>, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<ReturnType<typeof useStoreVisibleUsingPUTHook>>>,
        TError,
        { attrProfileTechnicalName: string; technicalName: string; params?: StoreVisibleUsingPUTParams },
        TContext
    >
}): UseMutationOptions<
    Awaited<ReturnType<ReturnType<typeof useStoreVisibleUsingPUTHook>>>,
    TError,
    { attrProfileTechnicalName: string; technicalName: string; params?: StoreVisibleUsingPUTParams },
    TContext
> => {
    const { mutation: mutationOptions } = options ?? {}

    const storeVisibleUsingPUT = useStoreVisibleUsingPUTHook()

    const mutationFn: MutationFunction<
        Awaited<ReturnType<ReturnType<typeof useStoreVisibleUsingPUTHook>>>,
        { attrProfileTechnicalName: string; technicalName: string; params?: StoreVisibleUsingPUTParams }
    > = (props) => {
        const { attrProfileTechnicalName, technicalName, params } = props ?? {}

        return storeVisibleUsingPUT(attrProfileTechnicalName, technicalName, params)
    }

    return { mutationFn, ...mutationOptions }
}

export type StoreVisibleUsingPUTMutationResult = NonNullable<Awaited<ReturnType<ReturnType<typeof useStoreVisibleUsingPUTHook>>>>

export type StoreVisibleUsingPUTMutationError = ErrorType<unknown>

/**
 * @summary storeVisible
 */
export const useStoreVisibleUsingPUT = <TError = ErrorType<unknown>, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<ReturnType<typeof useStoreVisibleUsingPUTHook>>>,
        TError,
        { attrProfileTechnicalName: string; technicalName: string; params?: StoreVisibleUsingPUTParams },
        TContext
    >
}) => {
    const mutationOptions = useStoreVisibleUsingPUTMutationOptions(options)

    return useMutation(mutationOptions)
}

/**
 * @summary storeInvisible
 */
export const useStoreInvisibleUsingDELETEHook = () => {
    const storeInvisibleUsingDELETE = useCustomClient<void>()

    return (attrProfileTechnicalName: string, technicalName: string, params?: StoreInvisibleUsingDELETEParams) => {
        return storeInvisibleUsingDELETE({
            url: `/attributes/attribute/invisible/${attrProfileTechnicalName}/${technicalName}`,
            method: 'delete',
            params,
        })
    }
}

export const useStoreInvisibleUsingDELETEMutationOptions = <TError = ErrorType<unknown>, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<ReturnType<typeof useStoreInvisibleUsingDELETEHook>>>,
        TError,
        { attrProfileTechnicalName: string; technicalName: string; params?: StoreInvisibleUsingDELETEParams },
        TContext
    >
}): UseMutationOptions<
    Awaited<ReturnType<ReturnType<typeof useStoreInvisibleUsingDELETEHook>>>,
    TError,
    { attrProfileTechnicalName: string; technicalName: string; params?: StoreInvisibleUsingDELETEParams },
    TContext
> => {
    const { mutation: mutationOptions } = options ?? {}

    const storeInvisibleUsingDELETE = useStoreInvisibleUsingDELETEHook()

    const mutationFn: MutationFunction<
        Awaited<ReturnType<ReturnType<typeof useStoreInvisibleUsingDELETEHook>>>,
        { attrProfileTechnicalName: string; technicalName: string; params?: StoreInvisibleUsingDELETEParams }
    > = (props) => {
        const { attrProfileTechnicalName, technicalName, params } = props ?? {}

        return storeInvisibleUsingDELETE(attrProfileTechnicalName, technicalName, params)
    }

    return { mutationFn, ...mutationOptions }
}

export type StoreInvisibleUsingDELETEMutationResult = NonNullable<Awaited<ReturnType<ReturnType<typeof useStoreInvisibleUsingDELETEHook>>>>

export type StoreInvisibleUsingDELETEMutationError = ErrorType<unknown>

/**
 * @summary storeInvisible
 */
export const useStoreInvisibleUsingDELETE = <TError = ErrorType<unknown>, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<ReturnType<typeof useStoreInvisibleUsingDELETEHook>>>,
        TError,
        { attrProfileTechnicalName: string; technicalName: string; params?: StoreInvisibleUsingDELETEParams },
        TContext
    >
}) => {
    const mutationOptions = useStoreInvisibleUsingDELETEMutationOptions(options)

    return useMutation(mutationOptions)
}

/**
 * @summary storeExistAttribute
 */
export const useStoreExistAttributeUsingPUTHook = () => {
    const storeExistAttributeUsingPUT = useCustomClient<void>()

    return (attributeBody: BodyType<AttributeBody>, params?: StoreExistAttributeUsingPUTParams) => {
        return storeExistAttributeUsingPUT({
            url: `/attributes/attribute/store`,
            method: 'put',
            headers: { 'Content-Type': 'application/json' },
            data: attributeBody,
            params,
        })
    }
}

export const useStoreExistAttributeUsingPUTMutationOptions = <TError = ErrorType<unknown>, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<ReturnType<typeof useStoreExistAttributeUsingPUTHook>>>,
        TError,
        { data: BodyType<AttributeBody>; params?: StoreExistAttributeUsingPUTParams },
        TContext
    >
}): UseMutationOptions<
    Awaited<ReturnType<ReturnType<typeof useStoreExistAttributeUsingPUTHook>>>,
    TError,
    { data: BodyType<AttributeBody>; params?: StoreExistAttributeUsingPUTParams },
    TContext
> => {
    const { mutation: mutationOptions } = options ?? {}

    const storeExistAttributeUsingPUT = useStoreExistAttributeUsingPUTHook()

    const mutationFn: MutationFunction<
        Awaited<ReturnType<ReturnType<typeof useStoreExistAttributeUsingPUTHook>>>,
        { data: BodyType<AttributeBody>; params?: StoreExistAttributeUsingPUTParams }
    > = (props) => {
        const { data, params } = props ?? {}

        return storeExistAttributeUsingPUT(data, params)
    }

    return { mutationFn, ...mutationOptions }
}

export type StoreExistAttributeUsingPUTMutationResult = NonNullable<Awaited<ReturnType<ReturnType<typeof useStoreExistAttributeUsingPUTHook>>>>
export type StoreExistAttributeUsingPUTMutationBody = BodyType<AttributeBody>
export type StoreExistAttributeUsingPUTMutationError = ErrorType<unknown>

/**
 * @summary storeExistAttribute
 */
export const useStoreExistAttributeUsingPUT = <TError = ErrorType<unknown>, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<ReturnType<typeof useStoreExistAttributeUsingPUTHook>>>,
        TError,
        { data: BodyType<AttributeBody>; params?: StoreExistAttributeUsingPUTParams },
        TContext
    >
}) => {
    const mutationOptions = useStoreExistAttributeUsingPUTMutationOptions(options)

    return useMutation(mutationOptions)
}

/**
 * @summary storeNewAttribute
 */
export const useStoreNewAttributeUsingPOSTHook = () => {
    const storeNewAttributeUsingPOST = useCustomClient<void>()

    return (atrProfTechnicalName: string, attributeBody: BodyType<AttributeBody>, params?: StoreNewAttributeUsingPOSTParams) => {
        return storeNewAttributeUsingPOST({
            url: `/attributes/attribute/store/${atrProfTechnicalName}`,
            method: 'post',
            headers: { 'Content-Type': 'application/json' },
            data: attributeBody,
            params,
        })
    }
}

export const useStoreNewAttributeUsingPOSTMutationOptions = <TError = ErrorType<unknown>, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<ReturnType<typeof useStoreNewAttributeUsingPOSTHook>>>,
        TError,
        { atrProfTechnicalName: string; data: BodyType<AttributeBody>; params?: StoreNewAttributeUsingPOSTParams },
        TContext
    >
}): UseMutationOptions<
    Awaited<ReturnType<ReturnType<typeof useStoreNewAttributeUsingPOSTHook>>>,
    TError,
    { atrProfTechnicalName: string; data: BodyType<AttributeBody>; params?: StoreNewAttributeUsingPOSTParams },
    TContext
> => {
    const { mutation: mutationOptions } = options ?? {}

    const storeNewAttributeUsingPOST = useStoreNewAttributeUsingPOSTHook()

    const mutationFn: MutationFunction<
        Awaited<ReturnType<ReturnType<typeof useStoreNewAttributeUsingPOSTHook>>>,
        { atrProfTechnicalName: string; data: BodyType<AttributeBody>; params?: StoreNewAttributeUsingPOSTParams }
    > = (props) => {
        const { atrProfTechnicalName, data, params } = props ?? {}

        return storeNewAttributeUsingPOST(atrProfTechnicalName, data, params)
    }

    return { mutationFn, ...mutationOptions }
}

export type StoreNewAttributeUsingPOSTMutationResult = NonNullable<Awaited<ReturnType<ReturnType<typeof useStoreNewAttributeUsingPOSTHook>>>>
export type StoreNewAttributeUsingPOSTMutationBody = BodyType<AttributeBody>
export type StoreNewAttributeUsingPOSTMutationError = ErrorType<unknown>

/**
 * @summary storeNewAttribute
 */
export const useStoreNewAttributeUsingPOST = <TError = ErrorType<unknown>, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<ReturnType<typeof useStoreNewAttributeUsingPOSTHook>>>,
        TError,
        { atrProfTechnicalName: string; data: BodyType<AttributeBody>; params?: StoreNewAttributeUsingPOSTParams },
        TContext
    >
}) => {
    const mutationOptions = useStoreNewAttributeUsingPOSTMutationOptions(options)

    return useMutation(mutationOptions)
}

/**
 * @summary storeValid
 */
export const useStoreValidUsingPUTHook = () => {
    const storeValidUsingPUT = useCustomClient<void>()

    return (attrProfileTechnicalName: string, technicalName: string, params?: StoreValidUsingPUTParams) => {
        return storeValidUsingPUT({ url: `/attributes/attribute/valid/${attrProfileTechnicalName}/${technicalName}`, method: 'put', params })
    }
}

export const useStoreValidUsingPUTMutationOptions = <TError = ErrorType<unknown>, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<ReturnType<typeof useStoreValidUsingPUTHook>>>,
        TError,
        { attrProfileTechnicalName: string; technicalName: string; params?: StoreValidUsingPUTParams },
        TContext
    >
}): UseMutationOptions<
    Awaited<ReturnType<ReturnType<typeof useStoreValidUsingPUTHook>>>,
    TError,
    { attrProfileTechnicalName: string; technicalName: string; params?: StoreValidUsingPUTParams },
    TContext
> => {
    const { mutation: mutationOptions } = options ?? {}

    const storeValidUsingPUT = useStoreValidUsingPUTHook()

    const mutationFn: MutationFunction<
        Awaited<ReturnType<ReturnType<typeof useStoreValidUsingPUTHook>>>,
        { attrProfileTechnicalName: string; technicalName: string; params?: StoreValidUsingPUTParams }
    > = (props) => {
        const { attrProfileTechnicalName, technicalName, params } = props ?? {}

        return storeValidUsingPUT(attrProfileTechnicalName, technicalName, params)
    }

    return { mutationFn, ...mutationOptions }
}

export type StoreValidUsingPUTMutationResult = NonNullable<Awaited<ReturnType<ReturnType<typeof useStoreValidUsingPUTHook>>>>

export type StoreValidUsingPUTMutationError = ErrorType<unknown>

/**
 * @summary storeValid
 */
export const useStoreValidUsingPUT = <TError = ErrorType<unknown>, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<ReturnType<typeof useStoreValidUsingPUTHook>>>,
        TError,
        { attrProfileTechnicalName: string; technicalName: string; params?: StoreValidUsingPUTParams },
        TContext
    >
}) => {
    const mutationOptions = useStoreValidUsingPUTMutationOptions(options)

    return useMutation(mutationOptions)
}

/**
 * @summary storeUnvalid
 */
export const useStoreUnvalidUsingDELETEHook = () => {
    const storeUnvalidUsingDELETE = useCustomClient<void>()

    return (attrProfileTechnicalName: string, technicalName: string, params?: StoreUnvalidUsingDELETEParams) => {
        return storeUnvalidUsingDELETE({ url: `/attributes/attribute/valid/${attrProfileTechnicalName}/${technicalName}`, method: 'delete', params })
    }
}

export const useStoreUnvalidUsingDELETEMutationOptions = <TError = ErrorType<unknown>, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<ReturnType<typeof useStoreUnvalidUsingDELETEHook>>>,
        TError,
        { attrProfileTechnicalName: string; technicalName: string; params?: StoreUnvalidUsingDELETEParams },
        TContext
    >
}): UseMutationOptions<
    Awaited<ReturnType<ReturnType<typeof useStoreUnvalidUsingDELETEHook>>>,
    TError,
    { attrProfileTechnicalName: string; technicalName: string; params?: StoreUnvalidUsingDELETEParams },
    TContext
> => {
    const { mutation: mutationOptions } = options ?? {}

    const storeUnvalidUsingDELETE = useStoreUnvalidUsingDELETEHook()

    const mutationFn: MutationFunction<
        Awaited<ReturnType<ReturnType<typeof useStoreUnvalidUsingDELETEHook>>>,
        { attrProfileTechnicalName: string; technicalName: string; params?: StoreUnvalidUsingDELETEParams }
    > = (props) => {
        const { attrProfileTechnicalName, technicalName, params } = props ?? {}

        return storeUnvalidUsingDELETE(attrProfileTechnicalName, technicalName, params)
    }

    return { mutationFn, ...mutationOptions }
}

export type StoreUnvalidUsingDELETEMutationResult = NonNullable<Awaited<ReturnType<ReturnType<typeof useStoreUnvalidUsingDELETEHook>>>>

export type StoreUnvalidUsingDELETEMutationError = ErrorType<unknown>

/**
 * @summary storeUnvalid
 */
export const useStoreUnvalidUsingDELETE = <TError = ErrorType<unknown>, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<ReturnType<typeof useStoreUnvalidUsingDELETEHook>>>,
        TError,
        { attrProfileTechnicalName: string; technicalName: string; params?: StoreUnvalidUsingDELETEParams },
        TContext
    >
}) => {
    const mutationOptions = useStoreUnvalidUsingDELETEMutationOptions(options)

    return useMutation(mutationOptions)
}

/**
 * @summary storeNewAttrProfile
 */
export const useStoreNewAttrProfileUsingPOSTHook = () => {
    const storeNewAttrProfileUsingPOST = useCustomClient<void>()

    return (attributeProfileBody: BodyType<AttributeProfileBody>, params?: StoreNewAttrProfileUsingPOSTParams) => {
        return storeNewAttrProfileUsingPOST({
            url: `/attrprofiles/attrprofile/store`,
            method: 'post',
            headers: { 'Content-Type': 'application/json' },
            data: attributeProfileBody,
            params,
        })
    }
}

export const useStoreNewAttrProfileUsingPOSTMutationOptions = <TError = ErrorType<unknown>, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<ReturnType<typeof useStoreNewAttrProfileUsingPOSTHook>>>,
        TError,
        { data: BodyType<AttributeProfileBody>; params?: StoreNewAttrProfileUsingPOSTParams },
        TContext
    >
}): UseMutationOptions<
    Awaited<ReturnType<ReturnType<typeof useStoreNewAttrProfileUsingPOSTHook>>>,
    TError,
    { data: BodyType<AttributeProfileBody>; params?: StoreNewAttrProfileUsingPOSTParams },
    TContext
> => {
    const { mutation: mutationOptions } = options ?? {}

    const storeNewAttrProfileUsingPOST = useStoreNewAttrProfileUsingPOSTHook()

    const mutationFn: MutationFunction<
        Awaited<ReturnType<ReturnType<typeof useStoreNewAttrProfileUsingPOSTHook>>>,
        { data: BodyType<AttributeProfileBody>; params?: StoreNewAttrProfileUsingPOSTParams }
    > = (props) => {
        const { data, params } = props ?? {}

        return storeNewAttrProfileUsingPOST(data, params)
    }

    return { mutationFn, ...mutationOptions }
}

export type StoreNewAttrProfileUsingPOSTMutationResult = NonNullable<Awaited<ReturnType<ReturnType<typeof useStoreNewAttrProfileUsingPOSTHook>>>>
export type StoreNewAttrProfileUsingPOSTMutationBody = BodyType<AttributeProfileBody>
export type StoreNewAttrProfileUsingPOSTMutationError = ErrorType<unknown>

/**
 * @summary storeNewAttrProfile
 */
export const useStoreNewAttrProfileUsingPOST = <TError = ErrorType<unknown>, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<ReturnType<typeof useStoreNewAttrProfileUsingPOSTHook>>>,
        TError,
        { data: BodyType<AttributeProfileBody>; params?: StoreNewAttrProfileUsingPOSTParams },
        TContext
    >
}) => {
    const mutationOptions = useStoreNewAttrProfileUsingPOSTMutationOptions(options)

    return useMutation(mutationOptions)
}

/**
 * @summary storeExistAttrProfile
 */
export const useStoreExistAttrProfileUsingPUTHook = () => {
    const storeExistAttrProfileUsingPUT = useCustomClient<void>()

    return (attributeProfileBody: BodyType<AttributeProfileBody>, params?: StoreExistAttrProfileUsingPUTParams) => {
        return storeExistAttrProfileUsingPUT({
            url: `/attrprofiles/attrprofile/store`,
            method: 'put',
            headers: { 'Content-Type': 'application/json' },
            data: attributeProfileBody,
            params,
        })
    }
}

export const useStoreExistAttrProfileUsingPUTMutationOptions = <TError = ErrorType<unknown>, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<ReturnType<typeof useStoreExistAttrProfileUsingPUTHook>>>,
        TError,
        { data: BodyType<AttributeProfileBody>; params?: StoreExistAttrProfileUsingPUTParams },
        TContext
    >
}): UseMutationOptions<
    Awaited<ReturnType<ReturnType<typeof useStoreExistAttrProfileUsingPUTHook>>>,
    TError,
    { data: BodyType<AttributeProfileBody>; params?: StoreExistAttrProfileUsingPUTParams },
    TContext
> => {
    const { mutation: mutationOptions } = options ?? {}

    const storeExistAttrProfileUsingPUT = useStoreExistAttrProfileUsingPUTHook()

    const mutationFn: MutationFunction<
        Awaited<ReturnType<ReturnType<typeof useStoreExistAttrProfileUsingPUTHook>>>,
        { data: BodyType<AttributeProfileBody>; params?: StoreExistAttrProfileUsingPUTParams }
    > = (props) => {
        const { data, params } = props ?? {}

        return storeExistAttrProfileUsingPUT(data, params)
    }

    return { mutationFn, ...mutationOptions }
}

export type StoreExistAttrProfileUsingPUTMutationResult = NonNullable<Awaited<ReturnType<ReturnType<typeof useStoreExistAttrProfileUsingPUTHook>>>>
export type StoreExistAttrProfileUsingPUTMutationBody = BodyType<AttributeProfileBody>
export type StoreExistAttrProfileUsingPUTMutationError = ErrorType<unknown>

/**
 * @summary storeExistAttrProfile
 */
export const useStoreExistAttrProfileUsingPUT = <TError = ErrorType<unknown>, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<ReturnType<typeof useStoreExistAttrProfileUsingPUTHook>>>,
        TError,
        { data: BodyType<AttributeProfileBody>; params?: StoreExistAttrProfileUsingPUTParams },
        TContext
    >
}) => {
    const mutationOptions = useStoreExistAttrProfileUsingPUTMutationOptions(options)

    return useMutation(mutationOptions)
}

/**
 * @summary storeExistGenericAttrProfile
 */
export const useStoreExistGenericAttrProfileUsingPUTHook = () => {
    const storeExistGenericAttrProfileUsingPUT = useCustomClient<void>()

    return (attributeProfileBody: BodyType<AttributeProfileBody>, params?: StoreExistGenericAttrProfileUsingPUTParams) => {
        return storeExistGenericAttrProfileUsingPUT({
            url: `/attrprofiles/attrprofile/store/generic`,
            method: 'put',
            headers: { 'Content-Type': 'application/json' },
            data: attributeProfileBody,
            params,
        })
    }
}

export const useStoreExistGenericAttrProfileUsingPUTMutationOptions = <TError = ErrorType<unknown>, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<ReturnType<typeof useStoreExistGenericAttrProfileUsingPUTHook>>>,
        TError,
        { data: BodyType<AttributeProfileBody>; params?: StoreExistGenericAttrProfileUsingPUTParams },
        TContext
    >
}): UseMutationOptions<
    Awaited<ReturnType<ReturnType<typeof useStoreExistGenericAttrProfileUsingPUTHook>>>,
    TError,
    { data: BodyType<AttributeProfileBody>; params?: StoreExistGenericAttrProfileUsingPUTParams },
    TContext
> => {
    const { mutation: mutationOptions } = options ?? {}

    const storeExistGenericAttrProfileUsingPUT = useStoreExistGenericAttrProfileUsingPUTHook()

    const mutationFn: MutationFunction<
        Awaited<ReturnType<ReturnType<typeof useStoreExistGenericAttrProfileUsingPUTHook>>>,
        { data: BodyType<AttributeProfileBody>; params?: StoreExistGenericAttrProfileUsingPUTParams }
    > = (props) => {
        const { data, params } = props ?? {}

        return storeExistGenericAttrProfileUsingPUT(data, params)
    }

    return { mutationFn, ...mutationOptions }
}

export type StoreExistGenericAttrProfileUsingPUTMutationResult = NonNullable<
    Awaited<ReturnType<ReturnType<typeof useStoreExistGenericAttrProfileUsingPUTHook>>>
>
export type StoreExistGenericAttrProfileUsingPUTMutationBody = BodyType<AttributeProfileBody>
export type StoreExistGenericAttrProfileUsingPUTMutationError = ErrorType<unknown>

/**
 * @summary storeExistGenericAttrProfile
 */
export const useStoreExistGenericAttrProfileUsingPUT = <TError = ErrorType<unknown>, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<ReturnType<typeof useStoreExistGenericAttrProfileUsingPUTHook>>>,
        TError,
        { data: BodyType<AttributeProfileBody>; params?: StoreExistGenericAttrProfileUsingPUTParams },
        TContext
    >
}) => {
    const mutationOptions = useStoreExistGenericAttrProfileUsingPUTMutationOptions(options)

    return useMutation(mutationOptions)
}

/**
 * @summary storeValid
 */
export const useStoreValidUsingPUT1Hook = () => {
    const storeValidUsingPUT1 = useCustomClient<void>()

    return (technicalName: string, params?: StoreValidUsingPUT1Params) => {
        return storeValidUsingPUT1({ url: `/attrprofiles/attrprofile/valid/${technicalName}`, method: 'put', params })
    }
}

export const useStoreValidUsingPUT1MutationOptions = <TError = ErrorType<unknown>, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<ReturnType<typeof useStoreValidUsingPUT1Hook>>>,
        TError,
        { technicalName: string; params?: StoreValidUsingPUT1Params },
        TContext
    >
}): UseMutationOptions<
    Awaited<ReturnType<ReturnType<typeof useStoreValidUsingPUT1Hook>>>,
    TError,
    { technicalName: string; params?: StoreValidUsingPUT1Params },
    TContext
> => {
    const { mutation: mutationOptions } = options ?? {}

    const storeValidUsingPUT1 = useStoreValidUsingPUT1Hook()

    const mutationFn: MutationFunction<
        Awaited<ReturnType<ReturnType<typeof useStoreValidUsingPUT1Hook>>>,
        { technicalName: string; params?: StoreValidUsingPUT1Params }
    > = (props) => {
        const { technicalName, params } = props ?? {}

        return storeValidUsingPUT1(technicalName, params)
    }

    return { mutationFn, ...mutationOptions }
}

export type StoreValidUsingPUT1MutationResult = NonNullable<Awaited<ReturnType<ReturnType<typeof useStoreValidUsingPUT1Hook>>>>

export type StoreValidUsingPUT1MutationError = ErrorType<unknown>

/**
 * @summary storeValid
 */
export const useStoreValidUsingPUT1 = <TError = ErrorType<unknown>, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<ReturnType<typeof useStoreValidUsingPUT1Hook>>>,
        TError,
        { technicalName: string; params?: StoreValidUsingPUT1Params },
        TContext
    >
}) => {
    const mutationOptions = useStoreValidUsingPUT1MutationOptions(options)

    return useMutation(mutationOptions)
}

/**
 * @summary storeUnValid
 */
export const useStoreUnValidUsingDELETEHook = () => {
    const storeUnValidUsingDELETE = useCustomClient<void>()

    return (technicalName: string, params?: StoreUnValidUsingDELETEParams) => {
        return storeUnValidUsingDELETE({ url: `/attrprofiles/attrprofile/valid/${technicalName}`, method: 'delete', params })
    }
}

export const useStoreUnValidUsingDELETEMutationOptions = <TError = ErrorType<unknown>, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<ReturnType<typeof useStoreUnValidUsingDELETEHook>>>,
        TError,
        { technicalName: string; params?: StoreUnValidUsingDELETEParams },
        TContext
    >
}): UseMutationOptions<
    Awaited<ReturnType<ReturnType<typeof useStoreUnValidUsingDELETEHook>>>,
    TError,
    { technicalName: string; params?: StoreUnValidUsingDELETEParams },
    TContext
> => {
    const { mutation: mutationOptions } = options ?? {}

    const storeUnValidUsingDELETE = useStoreUnValidUsingDELETEHook()

    const mutationFn: MutationFunction<
        Awaited<ReturnType<ReturnType<typeof useStoreUnValidUsingDELETEHook>>>,
        { technicalName: string; params?: StoreUnValidUsingDELETEParams }
    > = (props) => {
        const { technicalName, params } = props ?? {}

        return storeUnValidUsingDELETE(technicalName, params)
    }

    return { mutationFn, ...mutationOptions }
}

export type StoreUnValidUsingDELETEMutationResult = NonNullable<Awaited<ReturnType<ReturnType<typeof useStoreUnValidUsingDELETEHook>>>>

export type StoreUnValidUsingDELETEMutationError = ErrorType<unknown>

/**
 * @summary storeUnValid
 */
export const useStoreUnValidUsingDELETE = <TError = ErrorType<unknown>, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<ReturnType<typeof useStoreUnValidUsingDELETEHook>>>,
        TError,
        { technicalName: string; params?: StoreUnValidUsingDELETEParams },
        TContext
    >
}) => {
    const mutationOptions = useStoreUnValidUsingDELETEMutationOptions(options)

    return useMutation(mutationOptions)
}

/**
 * @summary getAttributeProfile
 */
export const useGetAttributeProfileUsingGETHook = () => {
    const getAttributeProfileUsingGET = useCustomClient<AttributeProfile>()

    return (technicalName: string, signal?: AbortSignal) => {
        return getAttributeProfileUsingGET({ url: `/attrprofiles/attrprofile/${technicalName}`, method: 'get', signal })
    }
}

export const getGetAttributeProfileUsingGETQueryKey = (technicalName: string) => [`/attrprofiles/attrprofile/${technicalName}`] as const

export const useGetAttributeProfileUsingGETQueryOptions = <
    TData = Awaited<ReturnType<ReturnType<typeof useGetAttributeProfileUsingGETHook>>>,
    TError = ErrorType<void>,
>(
    technicalName: string,
    options?: { query?: UseQueryOptions<Awaited<ReturnType<ReturnType<typeof useGetAttributeProfileUsingGETHook>>>, TError, TData> },
): UseQueryOptions<Awaited<ReturnType<ReturnType<typeof useGetAttributeProfileUsingGETHook>>>, TError, TData> & { queryKey: QueryKey } => {
    const { query: queryOptions } = options ?? {}

    const queryKey = queryOptions?.queryKey ?? getGetAttributeProfileUsingGETQueryKey(technicalName)

    const getAttributeProfileUsingGET = useGetAttributeProfileUsingGETHook()

    const queryFn: QueryFunction<Awaited<ReturnType<ReturnType<typeof useGetAttributeProfileUsingGETHook>>>> = ({ signal }) =>
        getAttributeProfileUsingGET(technicalName, signal)

    return { queryKey, queryFn, enabled: !!technicalName, ...queryOptions }
}

export type GetAttributeProfileUsingGETQueryResult = NonNullable<Awaited<ReturnType<ReturnType<typeof useGetAttributeProfileUsingGETHook>>>>
export type GetAttributeProfileUsingGETQueryError = ErrorType<void>

/**
 * @summary getAttributeProfile
 */
export const useGetAttributeProfileUsingGET = <
    TData = Awaited<ReturnType<ReturnType<typeof useGetAttributeProfileUsingGETHook>>>,
    TError = ErrorType<void>,
>(
    technicalName: string,
    options?: { query?: UseQueryOptions<Awaited<ReturnType<ReturnType<typeof useGetAttributeProfileUsingGETHook>>>, TError, TData> },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
    const queryOptions = useGetAttributeProfileUsingGETQueryOptions(technicalName, options)

    const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

    query.queryKey = queryOptions.queryKey

    return query
}

/**
 * @summary listAttrProfile
 */
export const useListAttrProfileUsingGETHook = () => {
    const listAttrProfileUsingGET = useCustomClient<AttributeProfilePreview>()

    return (attributeProfileFilterBody: BodyType<AttributeProfileFilterBody>, signal?: AbortSignal) => {
        return listAttrProfileUsingGET({ url: `/attrprofiles/list`, method: 'get', headers: { 'Content-Type': 'application/json' }, signal })
    }
}

export const getListAttrProfileUsingGETQueryKey = (attributeProfileFilterBody: AttributeProfileFilterBody) =>
    [`/attrprofiles/list`, attributeProfileFilterBody] as const

export const useListAttrProfileUsingGETQueryOptions = <
    TData = Awaited<ReturnType<ReturnType<typeof useListAttrProfileUsingGETHook>>>,
    TError = ErrorType<void>,
>(
    attributeProfileFilterBody: AttributeProfileFilterBody,
    options?: { query?: UseQueryOptions<Awaited<ReturnType<ReturnType<typeof useListAttrProfileUsingGETHook>>>, TError, TData> },
): UseQueryOptions<Awaited<ReturnType<ReturnType<typeof useListAttrProfileUsingGETHook>>>, TError, TData> & { queryKey: QueryKey } => {
    const { query: queryOptions } = options ?? {}

    const queryKey = queryOptions?.queryKey ?? getListAttrProfileUsingGETQueryKey(attributeProfileFilterBody)

    const listAttrProfileUsingGET = useListAttrProfileUsingGETHook()

    const queryFn: QueryFunction<Awaited<ReturnType<ReturnType<typeof useListAttrProfileUsingGETHook>>>> = ({ signal }) =>
        listAttrProfileUsingGET(attributeProfileFilterBody, signal)

    return { queryKey, queryFn, ...queryOptions }
}

export type ListAttrProfileUsingGETQueryResult = NonNullable<Awaited<ReturnType<ReturnType<typeof useListAttrProfileUsingGETHook>>>>
export type ListAttrProfileUsingGETQueryError = ErrorType<void>

/**
 * @summary listAttrProfile
 */
export const useListAttrProfileUsingGET = <TData = Awaited<ReturnType<ReturnType<typeof useListAttrProfileUsingGETHook>>>, TError = ErrorType<void>>(
    attributeProfileFilterBody: AttributeProfileFilterBody,
    options?: { query?: UseQueryOptions<Awaited<ReturnType<ReturnType<typeof useListAttrProfileUsingGETHook>>>, TError, TData> },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
    const queryOptions = useListAttrProfileUsingGETQueryOptions(attributeProfileFilterBody, options)

    const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

    query.queryKey = queryOptions.queryKey

    return query
}

/**
 * @summary listAttrProfile
 */
export const useListAttrProfileUsingPOSTHook = () => {
    const listAttrProfileUsingPOST = useCustomClient<AttributeProfilePreview | void>()

    return (attributeProfileFilterBody: BodyType<AttributeProfileFilterBody>) => {
        return listAttrProfileUsingPOST({
            url: `/attrprofiles/list`,
            method: 'post',
            headers: { 'Content-Type': 'application/json' },
            data: attributeProfileFilterBody,
        })
    }
}

export const useListAttrProfileUsingPOSTMutationOptions = <TError = ErrorType<unknown>, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<ReturnType<typeof useListAttrProfileUsingPOSTHook>>>,
        TError,
        { data: BodyType<AttributeProfileFilterBody> },
        TContext
    >
}): UseMutationOptions<
    Awaited<ReturnType<ReturnType<typeof useListAttrProfileUsingPOSTHook>>>,
    TError,
    { data: BodyType<AttributeProfileFilterBody> },
    TContext
> => {
    const { mutation: mutationOptions } = options ?? {}

    const listAttrProfileUsingPOST = useListAttrProfileUsingPOSTHook()

    const mutationFn: MutationFunction<
        Awaited<ReturnType<ReturnType<typeof useListAttrProfileUsingPOSTHook>>>,
        { data: BodyType<AttributeProfileFilterBody> }
    > = (props) => {
        const { data } = props ?? {}

        return listAttrProfileUsingPOST(data)
    }

    return { mutationFn, ...mutationOptions }
}

export type ListAttrProfileUsingPOSTMutationResult = NonNullable<Awaited<ReturnType<ReturnType<typeof useListAttrProfileUsingPOSTHook>>>>
export type ListAttrProfileUsingPOSTMutationBody = BodyType<AttributeProfileFilterBody>
export type ListAttrProfileUsingPOSTMutationError = ErrorType<unknown>

/**
 * @summary listAttrProfile
 */
export const useListAttrProfileUsingPOST = <TError = ErrorType<unknown>, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<ReturnType<typeof useListAttrProfileUsingPOSTHook>>>,
        TError,
        { data: BodyType<AttributeProfileFilterBody> },
        TContext
    >
}) => {
    const mutationOptions = useListAttrProfileUsingPOSTMutationOptions(options)

    return useMutation(mutationOptions)
}

/**
 * @summary listGenericAttrProfile
 */
export const useListGenericAttrProfileUsingGETHook = () => {
    const listGenericAttrProfileUsingGET = useCustomClient<AttributeProfilePreview>()

    return (attributeProfileFilterBody: BodyType<AttributeProfileFilterBody>, signal?: AbortSignal) => {
        return listGenericAttrProfileUsingGET({
            url: `/attrprofiles/list/generic`,
            method: 'get',
            headers: { 'Content-Type': 'application/json' },
            signal,
        })
    }
}

export const getListGenericAttrProfileUsingGETQueryKey = (attributeProfileFilterBody: AttributeProfileFilterBody) =>
    [`/attrprofiles/list/generic`, attributeProfileFilterBody] as const

export const useListGenericAttrProfileUsingGETQueryOptions = <
    TData = Awaited<ReturnType<ReturnType<typeof useListGenericAttrProfileUsingGETHook>>>,
    TError = ErrorType<void>,
>(
    attributeProfileFilterBody: AttributeProfileFilterBody,
    options?: { query?: UseQueryOptions<Awaited<ReturnType<ReturnType<typeof useListGenericAttrProfileUsingGETHook>>>, TError, TData> },
): UseQueryOptions<Awaited<ReturnType<ReturnType<typeof useListGenericAttrProfileUsingGETHook>>>, TError, TData> & { queryKey: QueryKey } => {
    const { query: queryOptions } = options ?? {}

    const queryKey = queryOptions?.queryKey ?? getListGenericAttrProfileUsingGETQueryKey(attributeProfileFilterBody)

    const listGenericAttrProfileUsingGET = useListGenericAttrProfileUsingGETHook()

    const queryFn: QueryFunction<Awaited<ReturnType<ReturnType<typeof useListGenericAttrProfileUsingGETHook>>>> = ({ signal }) =>
        listGenericAttrProfileUsingGET(attributeProfileFilterBody, signal)

    return { queryKey, queryFn, ...queryOptions }
}

export type ListGenericAttrProfileUsingGETQueryResult = NonNullable<Awaited<ReturnType<ReturnType<typeof useListGenericAttrProfileUsingGETHook>>>>
export type ListGenericAttrProfileUsingGETQueryError = ErrorType<void>

/**
 * @summary listGenericAttrProfile
 */
export const useListGenericAttrProfileUsingGET = <
    TData = Awaited<ReturnType<ReturnType<typeof useListGenericAttrProfileUsingGETHook>>>,
    TError = ErrorType<void>,
>(
    attributeProfileFilterBody: AttributeProfileFilterBody,
    options?: { query?: UseQueryOptions<Awaited<ReturnType<ReturnType<typeof useListGenericAttrProfileUsingGETHook>>>, TError, TData> },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
    const queryOptions = useListGenericAttrProfileUsingGETQueryOptions(attributeProfileFilterBody, options)

    const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

    query.queryKey = queryOptions.queryKey

    return query
}

/**
 * @summary listAttrProfileLM
 */
export const useListAttrProfileLMUsingGETHook = () => {
    const listAttrProfileLMUsingGET = useCustomClient<AttributeProfilePreview>()

    return (signal?: AbortSignal) => {
        return listAttrProfileLMUsingGET({ url: `/attrprofiles/listLM`, method: 'get', signal })
    }
}

export const getListAttrProfileLMUsingGETQueryKey = () => [`/attrprofiles/listLM`] as const

export const useListAttrProfileLMUsingGETQueryOptions = <
    TData = Awaited<ReturnType<ReturnType<typeof useListAttrProfileLMUsingGETHook>>>,
    TError = ErrorType<void>,
>(options?: {
    query?: UseQueryOptions<Awaited<ReturnType<ReturnType<typeof useListAttrProfileLMUsingGETHook>>>, TError, TData>
}): UseQueryOptions<Awaited<ReturnType<ReturnType<typeof useListAttrProfileLMUsingGETHook>>>, TError, TData> & { queryKey: QueryKey } => {
    const { query: queryOptions } = options ?? {}

    const queryKey = queryOptions?.queryKey ?? getListAttrProfileLMUsingGETQueryKey()

    const listAttrProfileLMUsingGET = useListAttrProfileLMUsingGETHook()

    const queryFn: QueryFunction<Awaited<ReturnType<ReturnType<typeof useListAttrProfileLMUsingGETHook>>>> = ({ signal }) =>
        listAttrProfileLMUsingGET(signal)

    return { queryKey, queryFn, ...queryOptions }
}

export type ListAttrProfileLMUsingGETQueryResult = NonNullable<Awaited<ReturnType<ReturnType<typeof useListAttrProfileLMUsingGETHook>>>>
export type ListAttrProfileLMUsingGETQueryError = ErrorType<void>

/**
 * @summary listAttrProfileLM
 */
export const useListAttrProfileLMUsingGET = <
    TData = Awaited<ReturnType<ReturnType<typeof useListAttrProfileLMUsingGETHook>>>,
    TError = ErrorType<void>,
>(options?: {
    query?: UseQueryOptions<Awaited<ReturnType<ReturnType<typeof useListAttrProfileLMUsingGETHook>>>, TError, TData>
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
    const queryOptions = useListAttrProfileLMUsingGETQueryOptions(options)

    const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

    query.queryKey = queryOptions.queryKey

    return query
}

/**
 * @summary storeNewCiTypeRelationshipTypeMap
 */
export const useStoreNewCiTypeRelationshipTypeMapUsingPOSTHook = () => {
    const storeNewCiTypeRelationshipTypeMapUsingPOST = useCustomClient<void>()

    return (ciTypeRelationshipTypeMapBody: BodyType<CiTypeRelationshipTypeMapBody>, params?: StoreNewCiTypeRelationshipTypeMapUsingPOSTParams) => {
        return storeNewCiTypeRelationshipTypeMapUsingPOST({
            url: `/cityperelationshiptypemaps/cityperelationshiptypemap/store`,
            method: 'post',
            headers: { 'Content-Type': 'application/json' },
            data: ciTypeRelationshipTypeMapBody,
            params,
        })
    }
}

export const useStoreNewCiTypeRelationshipTypeMapUsingPOSTMutationOptions = <TError = ErrorType<unknown>, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<ReturnType<typeof useStoreNewCiTypeRelationshipTypeMapUsingPOSTHook>>>,
        TError,
        { data: BodyType<CiTypeRelationshipTypeMapBody>; params?: StoreNewCiTypeRelationshipTypeMapUsingPOSTParams },
        TContext
    >
}): UseMutationOptions<
    Awaited<ReturnType<ReturnType<typeof useStoreNewCiTypeRelationshipTypeMapUsingPOSTHook>>>,
    TError,
    { data: BodyType<CiTypeRelationshipTypeMapBody>; params?: StoreNewCiTypeRelationshipTypeMapUsingPOSTParams },
    TContext
> => {
    const { mutation: mutationOptions } = options ?? {}

    const storeNewCiTypeRelationshipTypeMapUsingPOST = useStoreNewCiTypeRelationshipTypeMapUsingPOSTHook()

    const mutationFn: MutationFunction<
        Awaited<ReturnType<ReturnType<typeof useStoreNewCiTypeRelationshipTypeMapUsingPOSTHook>>>,
        { data: BodyType<CiTypeRelationshipTypeMapBody>; params?: StoreNewCiTypeRelationshipTypeMapUsingPOSTParams }
    > = (props) => {
        const { data, params } = props ?? {}

        return storeNewCiTypeRelationshipTypeMapUsingPOST(data, params)
    }

    return { mutationFn, ...mutationOptions }
}

export type StoreNewCiTypeRelationshipTypeMapUsingPOSTMutationResult = NonNullable<
    Awaited<ReturnType<ReturnType<typeof useStoreNewCiTypeRelationshipTypeMapUsingPOSTHook>>>
>
export type StoreNewCiTypeRelationshipTypeMapUsingPOSTMutationBody = BodyType<CiTypeRelationshipTypeMapBody>
export type StoreNewCiTypeRelationshipTypeMapUsingPOSTMutationError = ErrorType<unknown>

/**
 * @summary storeNewCiTypeRelationshipTypeMap
 */
export const useStoreNewCiTypeRelationshipTypeMapUsingPOST = <TError = ErrorType<unknown>, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<ReturnType<typeof useStoreNewCiTypeRelationshipTypeMapUsingPOSTHook>>>,
        TError,
        { data: BodyType<CiTypeRelationshipTypeMapBody>; params?: StoreNewCiTypeRelationshipTypeMapUsingPOSTParams },
        TContext
    >
}) => {
    const mutationOptions = useStoreNewCiTypeRelationshipTypeMapUsingPOSTMutationOptions(options)

    return useMutation(mutationOptions)
}

/**
 * @summary storeExistsCiTypeRelationshipTypeMap
 */
export const useStoreExistsCiTypeRelationshipTypeMapUsingPUTHook = () => {
    const storeExistsCiTypeRelationshipTypeMapUsingPUT = useCustomClient<void>()

    return (ciTypeRelationshipTypeMapBody: BodyType<CiTypeRelationshipTypeMapBody>, params?: StoreExistsCiTypeRelationshipTypeMapUsingPUTParams) => {
        return storeExistsCiTypeRelationshipTypeMapUsingPUT({
            url: `/cityperelationshiptypemaps/cityperelationshiptypemap/store`,
            method: 'put',
            headers: { 'Content-Type': 'application/json' },
            data: ciTypeRelationshipTypeMapBody,
            params,
        })
    }
}

export const useStoreExistsCiTypeRelationshipTypeMapUsingPUTMutationOptions = <TError = ErrorType<unknown>, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<ReturnType<typeof useStoreExistsCiTypeRelationshipTypeMapUsingPUTHook>>>,
        TError,
        { data: BodyType<CiTypeRelationshipTypeMapBody>; params?: StoreExistsCiTypeRelationshipTypeMapUsingPUTParams },
        TContext
    >
}): UseMutationOptions<
    Awaited<ReturnType<ReturnType<typeof useStoreExistsCiTypeRelationshipTypeMapUsingPUTHook>>>,
    TError,
    { data: BodyType<CiTypeRelationshipTypeMapBody>; params?: StoreExistsCiTypeRelationshipTypeMapUsingPUTParams },
    TContext
> => {
    const { mutation: mutationOptions } = options ?? {}

    const storeExistsCiTypeRelationshipTypeMapUsingPUT = useStoreExistsCiTypeRelationshipTypeMapUsingPUTHook()

    const mutationFn: MutationFunction<
        Awaited<ReturnType<ReturnType<typeof useStoreExistsCiTypeRelationshipTypeMapUsingPUTHook>>>,
        { data: BodyType<CiTypeRelationshipTypeMapBody>; params?: StoreExistsCiTypeRelationshipTypeMapUsingPUTParams }
    > = (props) => {
        const { data, params } = props ?? {}

        return storeExistsCiTypeRelationshipTypeMapUsingPUT(data, params)
    }

    return { mutationFn, ...mutationOptions }
}

export type StoreExistsCiTypeRelationshipTypeMapUsingPUTMutationResult = NonNullable<
    Awaited<ReturnType<ReturnType<typeof useStoreExistsCiTypeRelationshipTypeMapUsingPUTHook>>>
>
export type StoreExistsCiTypeRelationshipTypeMapUsingPUTMutationBody = BodyType<CiTypeRelationshipTypeMapBody>
export type StoreExistsCiTypeRelationshipTypeMapUsingPUTMutationError = ErrorType<unknown>

/**
 * @summary storeExistsCiTypeRelationshipTypeMap
 */
export const useStoreExistsCiTypeRelationshipTypeMapUsingPUT = <TError = ErrorType<unknown>, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<ReturnType<typeof useStoreExistsCiTypeRelationshipTypeMapUsingPUTHook>>>,
        TError,
        { data: BodyType<CiTypeRelationshipTypeMapBody>; params?: StoreExistsCiTypeRelationshipTypeMapUsingPUTParams },
        TContext
    >
}) => {
    const mutationOptions = useStoreExistsCiTypeRelationshipTypeMapUsingPUTMutationOptions(options)

    return useMutation(mutationOptions)
}

/**
 * @summary storeAdminEntity
 */
export const useStoreAdminEntityUsingPOSTHook = () => {
    const storeAdminEntityUsingPOST = useCustomClient<void>()

    return (ciTypeBody: BodyType<CiTypeBody>, params?: StoreAdminEntityUsingPOSTParams) => {
        return storeAdminEntityUsingPOST({
            url: `/citypes/adminentity/store`,
            method: 'post',
            headers: { 'Content-Type': 'application/json' },
            data: ciTypeBody,
            params,
        })
    }
}

export const useStoreAdminEntityUsingPOSTMutationOptions = <TError = ErrorType<unknown>, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<ReturnType<typeof useStoreAdminEntityUsingPOSTHook>>>,
        TError,
        { data: BodyType<CiTypeBody>; params?: StoreAdminEntityUsingPOSTParams },
        TContext
    >
}): UseMutationOptions<
    Awaited<ReturnType<ReturnType<typeof useStoreAdminEntityUsingPOSTHook>>>,
    TError,
    { data: BodyType<CiTypeBody>; params?: StoreAdminEntityUsingPOSTParams },
    TContext
> => {
    const { mutation: mutationOptions } = options ?? {}

    const storeAdminEntityUsingPOST = useStoreAdminEntityUsingPOSTHook()

    const mutationFn: MutationFunction<
        Awaited<ReturnType<ReturnType<typeof useStoreAdminEntityUsingPOSTHook>>>,
        { data: BodyType<CiTypeBody>; params?: StoreAdminEntityUsingPOSTParams }
    > = (props) => {
        const { data, params } = props ?? {}

        return storeAdminEntityUsingPOST(data, params)
    }

    return { mutationFn, ...mutationOptions }
}

export type StoreAdminEntityUsingPOSTMutationResult = NonNullable<Awaited<ReturnType<ReturnType<typeof useStoreAdminEntityUsingPOSTHook>>>>
export type StoreAdminEntityUsingPOSTMutationBody = BodyType<CiTypeBody>
export type StoreAdminEntityUsingPOSTMutationError = ErrorType<unknown>

/**
 * @summary storeAdminEntity
 */
export const useStoreAdminEntityUsingPOST = <TError = ErrorType<unknown>, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<ReturnType<typeof useStoreAdminEntityUsingPOSTHook>>>,
        TError,
        { data: BodyType<CiTypeBody>; params?: StoreAdminEntityUsingPOSTParams },
        TContext
    >
}) => {
    const mutationOptions = useStoreAdminEntityUsingPOSTMutationOptions(options)

    return useMutation(mutationOptions)
}

/**
 * @summary storeNewCiType
 */
export const useStoreNewCiTypeUsingPOSTHook = () => {
    const storeNewCiTypeUsingPOST = useCustomClient<void>()

    return (ciTypeBody: BodyType<CiTypeBody>, params?: StoreNewCiTypeUsingPOSTParams) => {
        return storeNewCiTypeUsingPOST({
            url: `/citypes/citype/store`,
            method: 'post',
            headers: { 'Content-Type': 'application/json' },
            data: ciTypeBody,
            params,
        })
    }
}

export const useStoreNewCiTypeUsingPOSTMutationOptions = <TError = ErrorType<unknown>, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<ReturnType<typeof useStoreNewCiTypeUsingPOSTHook>>>,
        TError,
        { data: BodyType<CiTypeBody>; params?: StoreNewCiTypeUsingPOSTParams },
        TContext
    >
}): UseMutationOptions<
    Awaited<ReturnType<ReturnType<typeof useStoreNewCiTypeUsingPOSTHook>>>,
    TError,
    { data: BodyType<CiTypeBody>; params?: StoreNewCiTypeUsingPOSTParams },
    TContext
> => {
    const { mutation: mutationOptions } = options ?? {}

    const storeNewCiTypeUsingPOST = useStoreNewCiTypeUsingPOSTHook()

    const mutationFn: MutationFunction<
        Awaited<ReturnType<ReturnType<typeof useStoreNewCiTypeUsingPOSTHook>>>,
        { data: BodyType<CiTypeBody>; params?: StoreNewCiTypeUsingPOSTParams }
    > = (props) => {
        const { data, params } = props ?? {}

        return storeNewCiTypeUsingPOST(data, params)
    }

    return { mutationFn, ...mutationOptions }
}

export type StoreNewCiTypeUsingPOSTMutationResult = NonNullable<Awaited<ReturnType<ReturnType<typeof useStoreNewCiTypeUsingPOSTHook>>>>
export type StoreNewCiTypeUsingPOSTMutationBody = BodyType<CiTypeBody>
export type StoreNewCiTypeUsingPOSTMutationError = ErrorType<unknown>

/**
 * @summary storeNewCiType
 */
export const useStoreNewCiTypeUsingPOST = <TError = ErrorType<unknown>, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<ReturnType<typeof useStoreNewCiTypeUsingPOSTHook>>>,
        TError,
        { data: BodyType<CiTypeBody>; params?: StoreNewCiTypeUsingPOSTParams },
        TContext
    >
}) => {
    const mutationOptions = useStoreNewCiTypeUsingPOSTMutationOptions(options)

    return useMutation(mutationOptions)
}

/**
 * @summary storeExistCiType
 */
export const useStoreExistCiTypeUsingPUTHook = () => {
    const storeExistCiTypeUsingPUT = useCustomClient<void>()

    return (ciTypeBody: BodyType<CiTypeBody>, params?: StoreExistCiTypeUsingPUTParams) => {
        return storeExistCiTypeUsingPUT({
            url: `/citypes/citype/store`,
            method: 'put',
            headers: { 'Content-Type': 'application/json' },
            data: ciTypeBody,
            params,
        })
    }
}

export const useStoreExistCiTypeUsingPUTMutationOptions = <TError = ErrorType<unknown>, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<ReturnType<typeof useStoreExistCiTypeUsingPUTHook>>>,
        TError,
        { data: BodyType<CiTypeBody>; params?: StoreExistCiTypeUsingPUTParams },
        TContext
    >
}): UseMutationOptions<
    Awaited<ReturnType<ReturnType<typeof useStoreExistCiTypeUsingPUTHook>>>,
    TError,
    { data: BodyType<CiTypeBody>; params?: StoreExistCiTypeUsingPUTParams },
    TContext
> => {
    const { mutation: mutationOptions } = options ?? {}

    const storeExistCiTypeUsingPUT = useStoreExistCiTypeUsingPUTHook()

    const mutationFn: MutationFunction<
        Awaited<ReturnType<ReturnType<typeof useStoreExistCiTypeUsingPUTHook>>>,
        { data: BodyType<CiTypeBody>; params?: StoreExistCiTypeUsingPUTParams }
    > = (props) => {
        const { data, params } = props ?? {}

        return storeExistCiTypeUsingPUT(data, params)
    }

    return { mutationFn, ...mutationOptions }
}

export type StoreExistCiTypeUsingPUTMutationResult = NonNullable<Awaited<ReturnType<ReturnType<typeof useStoreExistCiTypeUsingPUTHook>>>>
export type StoreExistCiTypeUsingPUTMutationBody = BodyType<CiTypeBody>
export type StoreExistCiTypeUsingPUTMutationError = ErrorType<unknown>

/**
 * @summary storeExistCiType
 */
export const useStoreExistCiTypeUsingPUT = <TError = ErrorType<unknown>, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<ReturnType<typeof useStoreExistCiTypeUsingPUTHook>>>,
        TError,
        { data: BodyType<CiTypeBody>; params?: StoreExistCiTypeUsingPUTParams },
        TContext
    >
}) => {
    const mutationOptions = useStoreExistCiTypeUsingPUTMutationOptions(options)

    return useMutation(mutationOptions)
}

/**
 * @summary storeValid
 */
export const useStoreValidUsingPUT2Hook = () => {
    const storeValidUsingPUT2 = useCustomClient<void>()

    return (technicalName: string, params?: StoreValidUsingPUT2Params) => {
        return storeValidUsingPUT2({ url: `/citypes/citype/valid/${technicalName}`, method: 'put', params })
    }
}

export const useStoreValidUsingPUT2MutationOptions = <TError = ErrorType<unknown>, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<ReturnType<typeof useStoreValidUsingPUT2Hook>>>,
        TError,
        { technicalName: string; params?: StoreValidUsingPUT2Params },
        TContext
    >
}): UseMutationOptions<
    Awaited<ReturnType<ReturnType<typeof useStoreValidUsingPUT2Hook>>>,
    TError,
    { technicalName: string; params?: StoreValidUsingPUT2Params },
    TContext
> => {
    const { mutation: mutationOptions } = options ?? {}

    const storeValidUsingPUT2 = useStoreValidUsingPUT2Hook()

    const mutationFn: MutationFunction<
        Awaited<ReturnType<ReturnType<typeof useStoreValidUsingPUT2Hook>>>,
        { technicalName: string; params?: StoreValidUsingPUT2Params }
    > = (props) => {
        const { technicalName, params } = props ?? {}

        return storeValidUsingPUT2(technicalName, params)
    }

    return { mutationFn, ...mutationOptions }
}

export type StoreValidUsingPUT2MutationResult = NonNullable<Awaited<ReturnType<ReturnType<typeof useStoreValidUsingPUT2Hook>>>>

export type StoreValidUsingPUT2MutationError = ErrorType<unknown>

/**
 * @summary storeValid
 */
export const useStoreValidUsingPUT2 = <TError = ErrorType<unknown>, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<ReturnType<typeof useStoreValidUsingPUT2Hook>>>,
        TError,
        { technicalName: string; params?: StoreValidUsingPUT2Params },
        TContext
    >
}) => {
    const mutationOptions = useStoreValidUsingPUT2MutationOptions(options)

    return useMutation(mutationOptions)
}

/**
 * @summary storeUnvalid
 */
export const useStoreUnvalidUsingDELETE1Hook = () => {
    const storeUnvalidUsingDELETE1 = useCustomClient<void>()

    return (technicalName: string, params?: StoreUnvalidUsingDELETE1Params) => {
        return storeUnvalidUsingDELETE1({ url: `/citypes/citype/valid/${technicalName}`, method: 'delete', params })
    }
}

export const useStoreUnvalidUsingDELETE1MutationOptions = <TError = ErrorType<unknown>, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<ReturnType<typeof useStoreUnvalidUsingDELETE1Hook>>>,
        TError,
        { technicalName: string; params?: StoreUnvalidUsingDELETE1Params },
        TContext
    >
}): UseMutationOptions<
    Awaited<ReturnType<ReturnType<typeof useStoreUnvalidUsingDELETE1Hook>>>,
    TError,
    { technicalName: string; params?: StoreUnvalidUsingDELETE1Params },
    TContext
> => {
    const { mutation: mutationOptions } = options ?? {}

    const storeUnvalidUsingDELETE1 = useStoreUnvalidUsingDELETE1Hook()

    const mutationFn: MutationFunction<
        Awaited<ReturnType<ReturnType<typeof useStoreUnvalidUsingDELETE1Hook>>>,
        { technicalName: string; params?: StoreUnvalidUsingDELETE1Params }
    > = (props) => {
        const { technicalName, params } = props ?? {}

        return storeUnvalidUsingDELETE1(technicalName, params)
    }

    return { mutationFn, ...mutationOptions }
}

export type StoreUnvalidUsingDELETE1MutationResult = NonNullable<Awaited<ReturnType<ReturnType<typeof useStoreUnvalidUsingDELETE1Hook>>>>

export type StoreUnvalidUsingDELETE1MutationError = ErrorType<unknown>

/**
 * @summary storeUnvalid
 */
export const useStoreUnvalidUsingDELETE1 = <TError = ErrorType<unknown>, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<ReturnType<typeof useStoreUnvalidUsingDELETE1Hook>>>,
        TError,
        { technicalName: string; params?: StoreUnvalidUsingDELETE1Params },
        TContext
    >
}) => {
    const mutationOptions = useStoreUnvalidUsingDELETE1MutationOptions(options)

    return useMutation(mutationOptions)
}

/**
 * @summary getCiType
 */
export const useGetCiTypeUsingGETHook = () => {
    const getCiTypeUsingGET = useCustomClient<CiType>()

    return (technicalName: string, signal?: AbortSignal) => {
        return getCiTypeUsingGET({ url: `/citypes/citype/${technicalName}`, method: 'get', signal })
    }
}

export const getGetCiTypeUsingGETQueryKey = (technicalName: string) => [`/citypes/citype/${technicalName}`] as const

export const useGetCiTypeUsingGETQueryOptions = <TData = Awaited<ReturnType<ReturnType<typeof useGetCiTypeUsingGETHook>>>, TError = ErrorType<void>>(
    technicalName: string,
    options?: { query?: UseQueryOptions<Awaited<ReturnType<ReturnType<typeof useGetCiTypeUsingGETHook>>>, TError, TData> },
): UseQueryOptions<Awaited<ReturnType<ReturnType<typeof useGetCiTypeUsingGETHook>>>, TError, TData> & { queryKey: QueryKey } => {
    const { query: queryOptions } = options ?? {}

    const queryKey = queryOptions?.queryKey ?? getGetCiTypeUsingGETQueryKey(technicalName)

    const getCiTypeUsingGET = useGetCiTypeUsingGETHook()

    const queryFn: QueryFunction<Awaited<ReturnType<ReturnType<typeof useGetCiTypeUsingGETHook>>>> = ({ signal }) =>
        getCiTypeUsingGET(technicalName, signal)

    return { queryKey, queryFn, enabled: !!technicalName, ...queryOptions }
}

export type GetCiTypeUsingGETQueryResult = NonNullable<Awaited<ReturnType<ReturnType<typeof useGetCiTypeUsingGETHook>>>>
export type GetCiTypeUsingGETQueryError = ErrorType<void>

/**
 * @summary getCiType
 */
export const useGetCiTypeUsingGET = <TData = Awaited<ReturnType<ReturnType<typeof useGetCiTypeUsingGETHook>>>, TError = ErrorType<void>>(
    technicalName: string,
    options?: { query?: UseQueryOptions<Awaited<ReturnType<ReturnType<typeof useGetCiTypeUsingGETHook>>>, TError, TData> },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
    const queryOptions = useGetCiTypeUsingGETQueryOptions(technicalName, options)

    const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

    query.queryKey = queryOptions.queryKey

    return query
}

/**
 * @summary storeAttributeTextation
 */
export const useStoreAttributeTextationUsingPUTHook = () => {
    const storeAttributeTextationUsingPUT = useCustomClient<void>()

    return (technicalName: string, attTecName: string, attributeBody: BodyType<AttributeBody>, params?: StoreAttributeTextationUsingPUTParams) => {
        return storeAttributeTextationUsingPUT({
            url: `/citypes/citype/${technicalName}/attribute/${attTecName}`,
            method: 'put',
            headers: { 'Content-Type': 'application/json' },
            data: attributeBody,
            params,
        })
    }
}

export const useStoreAttributeTextationUsingPUTMutationOptions = <TError = ErrorType<unknown>, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<ReturnType<typeof useStoreAttributeTextationUsingPUTHook>>>,
        TError,
        { technicalName: string; attTecName: string; data: BodyType<AttributeBody>; params?: StoreAttributeTextationUsingPUTParams },
        TContext
    >
}): UseMutationOptions<
    Awaited<ReturnType<ReturnType<typeof useStoreAttributeTextationUsingPUTHook>>>,
    TError,
    { technicalName: string; attTecName: string; data: BodyType<AttributeBody>; params?: StoreAttributeTextationUsingPUTParams },
    TContext
> => {
    const { mutation: mutationOptions } = options ?? {}

    const storeAttributeTextationUsingPUT = useStoreAttributeTextationUsingPUTHook()

    const mutationFn: MutationFunction<
        Awaited<ReturnType<ReturnType<typeof useStoreAttributeTextationUsingPUTHook>>>,
        { technicalName: string; attTecName: string; data: BodyType<AttributeBody>; params?: StoreAttributeTextationUsingPUTParams }
    > = (props) => {
        const { technicalName, attTecName, data, params } = props ?? {}

        return storeAttributeTextationUsingPUT(technicalName, attTecName, data, params)
    }

    return { mutationFn, ...mutationOptions }
}

export type StoreAttributeTextationUsingPUTMutationResult = NonNullable<
    Awaited<ReturnType<ReturnType<typeof useStoreAttributeTextationUsingPUTHook>>>
>
export type StoreAttributeTextationUsingPUTMutationBody = BodyType<AttributeBody>
export type StoreAttributeTextationUsingPUTMutationError = ErrorType<unknown>

/**
 * @summary storeAttributeTextation
 */
export const useStoreAttributeTextationUsingPUT = <TError = ErrorType<unknown>, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<ReturnType<typeof useStoreAttributeTextationUsingPUTHook>>>,
        TError,
        { technicalName: string; attTecName: string; data: BodyType<AttributeBody>; params?: StoreAttributeTextationUsingPUTParams },
        TContext
    >
}) => {
    const mutationOptions = useStoreAttributeTextationUsingPUTMutationOptions(options)

    return useMutation(mutationOptions)
}

/**
 * @summary deleteAttributeTextation
 */
export const useDeleteAttributeTextationUsingDELETEHook = () => {
    const deleteAttributeTextationUsingDELETE = useCustomClient<void>()

    return (technicalName: string, attTecName: string) => {
        return deleteAttributeTextationUsingDELETE({ url: `/citypes/citype/${technicalName}/attribute/${attTecName}`, method: 'delete' })
    }
}

export const useDeleteAttributeTextationUsingDELETEMutationOptions = <TError = ErrorType<unknown>, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<ReturnType<typeof useDeleteAttributeTextationUsingDELETEHook>>>,
        TError,
        { technicalName: string; attTecName: string },
        TContext
    >
}): UseMutationOptions<
    Awaited<ReturnType<ReturnType<typeof useDeleteAttributeTextationUsingDELETEHook>>>,
    TError,
    { technicalName: string; attTecName: string },
    TContext
> => {
    const { mutation: mutationOptions } = options ?? {}

    const deleteAttributeTextationUsingDELETE = useDeleteAttributeTextationUsingDELETEHook()

    const mutationFn: MutationFunction<
        Awaited<ReturnType<ReturnType<typeof useDeleteAttributeTextationUsingDELETEHook>>>,
        { technicalName: string; attTecName: string }
    > = (props) => {
        const { technicalName, attTecName } = props ?? {}

        return deleteAttributeTextationUsingDELETE(technicalName, attTecName)
    }

    return { mutationFn, ...mutationOptions }
}

export type DeleteAttributeTextationUsingDELETEMutationResult = NonNullable<
    Awaited<ReturnType<ReturnType<typeof useDeleteAttributeTextationUsingDELETEHook>>>
>

export type DeleteAttributeTextationUsingDELETEMutationError = ErrorType<unknown>

/**
 * @summary deleteAttributeTextation
 */
export const useDeleteAttributeTextationUsingDELETE = <TError = ErrorType<unknown>, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<ReturnType<typeof useDeleteAttributeTextationUsingDELETEHook>>>,
        TError,
        { technicalName: string; attTecName: string },
        TContext
    >
}) => {
    const mutationOptions = useDeleteAttributeTextationUsingDELETEMutationOptions(options)

    return useMutation(mutationOptions)
}

/**
 * @summary getAttributeOverrides
 */
export const useGetAttributeOverridesUsingGETHook = () => {
    const getAttributeOverridesUsingGET = useCustomClient<Attribute[]>()

    return (technicalName: string, signal?: AbortSignal) => {
        return getAttributeOverridesUsingGET({ url: `/citypes/citype/${technicalName}/attributeOverride`, method: 'get', signal })
    }
}

export const getGetAttributeOverridesUsingGETQueryKey = (technicalName: string) => [`/citypes/citype/${technicalName}/attributeOverride`] as const

export const useGetAttributeOverridesUsingGETQueryOptions = <
    TData = Awaited<ReturnType<ReturnType<typeof useGetAttributeOverridesUsingGETHook>>>,
    TError = ErrorType<void>,
>(
    technicalName: string,
    options?: { query?: UseQueryOptions<Awaited<ReturnType<ReturnType<typeof useGetAttributeOverridesUsingGETHook>>>, TError, TData> },
): UseQueryOptions<Awaited<ReturnType<ReturnType<typeof useGetAttributeOverridesUsingGETHook>>>, TError, TData> & { queryKey: QueryKey } => {
    const { query: queryOptions } = options ?? {}

    const queryKey = queryOptions?.queryKey ?? getGetAttributeOverridesUsingGETQueryKey(technicalName)

    const getAttributeOverridesUsingGET = useGetAttributeOverridesUsingGETHook()

    const queryFn: QueryFunction<Awaited<ReturnType<ReturnType<typeof useGetAttributeOverridesUsingGETHook>>>> = ({ signal }) =>
        getAttributeOverridesUsingGET(technicalName, signal)

    return { queryKey, queryFn, enabled: !!technicalName, ...queryOptions }
}

export type GetAttributeOverridesUsingGETQueryResult = NonNullable<Awaited<ReturnType<ReturnType<typeof useGetAttributeOverridesUsingGETHook>>>>
export type GetAttributeOverridesUsingGETQueryError = ErrorType<void>

/**
 * @summary getAttributeOverrides
 */
export const useGetAttributeOverridesUsingGET = <
    TData = Awaited<ReturnType<ReturnType<typeof useGetAttributeOverridesUsingGETHook>>>,
    TError = ErrorType<void>,
>(
    technicalName: string,
    options?: { query?: UseQueryOptions<Awaited<ReturnType<ReturnType<typeof useGetAttributeOverridesUsingGETHook>>>, TError, TData> },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
    const queryOptions = useGetAttributeOverridesUsingGETQueryOptions(technicalName, options)

    const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

    query.queryKey = queryOptions.queryKey

    return query
}

/**
 * @summary listRelatedCiTypes
 */
export const useListRelatedCiTypesUsingGETHook = () => {
    const listRelatedCiTypesUsingGET = useCustomClient<RelatedCiTypePreviewList>()

    return (technicalName: string, signal?: AbortSignal) => {
        return listRelatedCiTypesUsingGET({ url: `/citypes/citype/${technicalName}/related`, method: 'get', signal })
    }
}

export const getListRelatedCiTypesUsingGETQueryKey = (technicalName: string) => [`/citypes/citype/${technicalName}/related`] as const

export const useListRelatedCiTypesUsingGETQueryOptions = <
    TData = Awaited<ReturnType<ReturnType<typeof useListRelatedCiTypesUsingGETHook>>>,
    TError = ErrorType<void>,
>(
    technicalName: string,
    options?: { query?: UseQueryOptions<Awaited<ReturnType<ReturnType<typeof useListRelatedCiTypesUsingGETHook>>>, TError, TData> },
): UseQueryOptions<Awaited<ReturnType<ReturnType<typeof useListRelatedCiTypesUsingGETHook>>>, TError, TData> & { queryKey: QueryKey } => {
    const { query: queryOptions } = options ?? {}

    const queryKey = queryOptions?.queryKey ?? getListRelatedCiTypesUsingGETQueryKey(technicalName)

    const listRelatedCiTypesUsingGET = useListRelatedCiTypesUsingGETHook()

    const queryFn: QueryFunction<Awaited<ReturnType<ReturnType<typeof useListRelatedCiTypesUsingGETHook>>>> = ({ signal }) =>
        listRelatedCiTypesUsingGET(technicalName, signal)

    return { queryKey, queryFn, enabled: !!technicalName, ...queryOptions }
}

export type ListRelatedCiTypesUsingGETQueryResult = NonNullable<Awaited<ReturnType<ReturnType<typeof useListRelatedCiTypesUsingGETHook>>>>
export type ListRelatedCiTypesUsingGETQueryError = ErrorType<void>

/**
 * @summary listRelatedCiTypes
 */
export const useListRelatedCiTypesUsingGET = <
    TData = Awaited<ReturnType<ReturnType<typeof useListRelatedCiTypesUsingGETHook>>>,
    TError = ErrorType<void>,
>(
    technicalName: string,
    options?: { query?: UseQueryOptions<Awaited<ReturnType<ReturnType<typeof useListRelatedCiTypesUsingGETHook>>>, TError, TData> },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
    const queryOptions = useListRelatedCiTypesUsingGETQueryOptions(technicalName, options)

    const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

    query.queryKey = queryOptions.queryKey

    return query
}

/**
 * @summary getSummarizingCard
 */
export const useGetSummarizingCardUsingGETHook = () => {
    const getSummarizingCardUsingGET = useCustomClient<SummarizingCardUi>()

    return (technicalName: string, signal?: AbortSignal) => {
        return getSummarizingCardUsingGET({ url: `/citypes/citype/${technicalName}/summarizingcard`, method: 'get', signal })
    }
}

export const getGetSummarizingCardUsingGETQueryKey = (technicalName: string) => [`/citypes/citype/${technicalName}/summarizingcard`] as const

export const useGetSummarizingCardUsingGETQueryOptions = <
    TData = Awaited<ReturnType<ReturnType<typeof useGetSummarizingCardUsingGETHook>>>,
    TError = ErrorType<void>,
>(
    technicalName: string,
    options?: { query?: UseQueryOptions<Awaited<ReturnType<ReturnType<typeof useGetSummarizingCardUsingGETHook>>>, TError, TData> },
): UseQueryOptions<Awaited<ReturnType<ReturnType<typeof useGetSummarizingCardUsingGETHook>>>, TError, TData> & { queryKey: QueryKey } => {
    const { query: queryOptions } = options ?? {}

    const queryKey = queryOptions?.queryKey ?? getGetSummarizingCardUsingGETQueryKey(technicalName)

    const getSummarizingCardUsingGET = useGetSummarizingCardUsingGETHook()

    const queryFn: QueryFunction<Awaited<ReturnType<ReturnType<typeof useGetSummarizingCardUsingGETHook>>>> = ({ signal }) =>
        getSummarizingCardUsingGET(technicalName, signal)

    return { queryKey, queryFn, enabled: !!technicalName, ...queryOptions }
}

export type GetSummarizingCardUsingGETQueryResult = NonNullable<Awaited<ReturnType<ReturnType<typeof useGetSummarizingCardUsingGETHook>>>>
export type GetSummarizingCardUsingGETQueryError = ErrorType<void>

/**
 * @summary getSummarizingCard
 */
export const useGetSummarizingCardUsingGET = <
    TData = Awaited<ReturnType<ReturnType<typeof useGetSummarizingCardUsingGETHook>>>,
    TError = ErrorType<void>,
>(
    technicalName: string,
    options?: { query?: UseQueryOptions<Awaited<ReturnType<ReturnType<typeof useGetSummarizingCardUsingGETHook>>>, TError, TData> },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
    const queryOptions = useGetSummarizingCardUsingGETQueryOptions(technicalName, options)

    const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

    query.queryKey = queryOptions.queryKey

    return query
}

/**
 * @summary setSummarizingCard
 */
export const useSetSummarizingCardUsingPUTHook = () => {
    const setSummarizingCardUsingPUT = useCustomClient<void>()

    return (technicalName: string, summarizingCardUi: BodyType<SummarizingCardUi>) => {
        return setSummarizingCardUsingPUT({
            url: `/citypes/citype/${technicalName}/summarizingcard`,
            method: 'put',
            headers: { 'Content-Type': 'application/json' },
            data: summarizingCardUi,
        })
    }
}

export const useSetSummarizingCardUsingPUTMutationOptions = <TError = ErrorType<unknown>, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<ReturnType<typeof useSetSummarizingCardUsingPUTHook>>>,
        TError,
        { technicalName: string; data: BodyType<SummarizingCardUi> },
        TContext
    >
}): UseMutationOptions<
    Awaited<ReturnType<ReturnType<typeof useSetSummarizingCardUsingPUTHook>>>,
    TError,
    { technicalName: string; data: BodyType<SummarizingCardUi> },
    TContext
> => {
    const { mutation: mutationOptions } = options ?? {}

    const setSummarizingCardUsingPUT = useSetSummarizingCardUsingPUTHook()

    const mutationFn: MutationFunction<
        Awaited<ReturnType<ReturnType<typeof useSetSummarizingCardUsingPUTHook>>>,
        { technicalName: string; data: BodyType<SummarizingCardUi> }
    > = (props) => {
        const { technicalName, data } = props ?? {}

        return setSummarizingCardUsingPUT(technicalName, data)
    }

    return { mutationFn, ...mutationOptions }
}

export type SetSummarizingCardUsingPUTMutationResult = NonNullable<Awaited<ReturnType<ReturnType<typeof useSetSummarizingCardUsingPUTHook>>>>
export type SetSummarizingCardUsingPUTMutationBody = BodyType<SummarizingCardUi>
export type SetSummarizingCardUsingPUTMutationError = ErrorType<unknown>

/**
 * @summary setSummarizingCard
 */
export const useSetSummarizingCardUsingPUT = <TError = ErrorType<unknown>, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<ReturnType<typeof useSetSummarizingCardUsingPUTHook>>>,
        TError,
        { technicalName: string; data: BodyType<SummarizingCardUi> },
        TContext
    >
}) => {
    const mutationOptions = useSetSummarizingCardUsingPUTMutationOptions(options)

    return useMutation(mutationOptions)
}

/**
 * @summary deleteSummarizingCard
 */
export const useDeleteSummarizingCardUsingDELETEHook = () => {
    const deleteSummarizingCardUsingDELETE = useCustomClient<void>()

    return (technicalName: string) => {
        return deleteSummarizingCardUsingDELETE({ url: `/citypes/citype/${technicalName}/summarizingcard`, method: 'delete' })
    }
}

export const useDeleteSummarizingCardUsingDELETEMutationOptions = <TError = ErrorType<unknown>, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<ReturnType<typeof useDeleteSummarizingCardUsingDELETEHook>>>,
        TError,
        { technicalName: string },
        TContext
    >
}): UseMutationOptions<
    Awaited<ReturnType<ReturnType<typeof useDeleteSummarizingCardUsingDELETEHook>>>,
    TError,
    { technicalName: string },
    TContext
> => {
    const { mutation: mutationOptions } = options ?? {}

    const deleteSummarizingCardUsingDELETE = useDeleteSummarizingCardUsingDELETEHook()

    const mutationFn: MutationFunction<Awaited<ReturnType<ReturnType<typeof useDeleteSummarizingCardUsingDELETEHook>>>, { technicalName: string }> = (
        props,
    ) => {
        const { technicalName } = props ?? {}

        return deleteSummarizingCardUsingDELETE(technicalName)
    }

    return { mutationFn, ...mutationOptions }
}

export type DeleteSummarizingCardUsingDELETEMutationResult = NonNullable<
    Awaited<ReturnType<ReturnType<typeof useDeleteSummarizingCardUsingDELETEHook>>>
>

export type DeleteSummarizingCardUsingDELETEMutationError = ErrorType<unknown>

/**
 * @summary deleteSummarizingCard
 */
export const useDeleteSummarizingCardUsingDELETE = <TError = ErrorType<unknown>, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<ReturnType<typeof useDeleteSummarizingCardUsingDELETEHook>>>,
        TError,
        { technicalName: string },
        TContext
    >
}) => {
    const mutationOptions = useDeleteSummarizingCardUsingDELETEMutationOptions(options)

    return useMutation(mutationOptions)
}

/**
 * @summary generateCodeAndURL
 */
export const useGenerateCodeAndURLUsingGET1Hook = () => {
    const generateCodeAndURLUsingGET1 = useCustomClient<CiCode>()

    return (technicalName: string, params?: GenerateCodeAndURLUsingGET1Params, signal?: AbortSignal) => {
        return generateCodeAndURLUsingGET1({ url: `/citypes/generate/${technicalName}`, method: 'get', params, signal })
    }
}

export const getGenerateCodeAndURLUsingGET1QueryKey = (technicalName: string, params?: GenerateCodeAndURLUsingGET1Params) =>
    [`/citypes/generate/${technicalName}`, ...(params ? [params] : [])] as const

export const useGenerateCodeAndURLUsingGET1QueryOptions = <
    TData = Awaited<ReturnType<ReturnType<typeof useGenerateCodeAndURLUsingGET1Hook>>>,
    TError = ErrorType<void>,
>(
    technicalName: string,
    params?: GenerateCodeAndURLUsingGET1Params,
    options?: { query?: UseQueryOptions<Awaited<ReturnType<ReturnType<typeof useGenerateCodeAndURLUsingGET1Hook>>>, TError, TData> },
): UseQueryOptions<Awaited<ReturnType<ReturnType<typeof useGenerateCodeAndURLUsingGET1Hook>>>, TError, TData> & { queryKey: QueryKey } => {
    const { query: queryOptions } = options ?? {}

    const queryKey = queryOptions?.queryKey ?? getGenerateCodeAndURLUsingGET1QueryKey(technicalName, params)

    const generateCodeAndURLUsingGET1 = useGenerateCodeAndURLUsingGET1Hook()

    const queryFn: QueryFunction<Awaited<ReturnType<ReturnType<typeof useGenerateCodeAndURLUsingGET1Hook>>>> = ({ signal }) =>
        generateCodeAndURLUsingGET1(technicalName, params, signal)

    return { queryKey, queryFn, enabled: !!technicalName, ...queryOptions }
}

export type GenerateCodeAndURLUsingGET1QueryResult = NonNullable<Awaited<ReturnType<ReturnType<typeof useGenerateCodeAndURLUsingGET1Hook>>>>
export type GenerateCodeAndURLUsingGET1QueryError = ErrorType<void>

/**
 * @summary generateCodeAndURL
 */
export const useGenerateCodeAndURLUsingGET1 = <
    TData = Awaited<ReturnType<ReturnType<typeof useGenerateCodeAndURLUsingGET1Hook>>>,
    TError = ErrorType<void>,
>(
    technicalName: string,
    params?: GenerateCodeAndURLUsingGET1Params,
    options?: { query?: UseQueryOptions<Awaited<ReturnType<ReturnType<typeof useGenerateCodeAndURLUsingGET1Hook>>>, TError, TData> },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
    const queryOptions = useGenerateCodeAndURLUsingGET1QueryOptions(technicalName, params, options)

    const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

    query.queryKey = queryOptions.queryKey

    return query
}

/**
 * @summary generateCodeAndURL
 */
export const useGenerateCodeAndURLUsingGETHook = () => {
    const generateCodeAndURLUsingGET = useCustomClient<CiCode[]>()

    return (technicalName: string, params: GenerateCodeAndURLUsingGETParams, signal?: AbortSignal) => {
        return generateCodeAndURLUsingGET({ url: `/citypes/generate/${technicalName}/bulk`, method: 'get', params, signal })
    }
}

export const getGenerateCodeAndURLUsingGETQueryKey = (technicalName: string, params: GenerateCodeAndURLUsingGETParams) =>
    [`/citypes/generate/${technicalName}/bulk`, ...(params ? [params] : [])] as const

export const useGenerateCodeAndURLUsingGETQueryOptions = <
    TData = Awaited<ReturnType<ReturnType<typeof useGenerateCodeAndURLUsingGETHook>>>,
    TError = ErrorType<void>,
>(
    technicalName: string,
    params: GenerateCodeAndURLUsingGETParams,
    options?: { query?: UseQueryOptions<Awaited<ReturnType<ReturnType<typeof useGenerateCodeAndURLUsingGETHook>>>, TError, TData> },
): UseQueryOptions<Awaited<ReturnType<ReturnType<typeof useGenerateCodeAndURLUsingGETHook>>>, TError, TData> & { queryKey: QueryKey } => {
    const { query: queryOptions } = options ?? {}

    const queryKey = queryOptions?.queryKey ?? getGenerateCodeAndURLUsingGETQueryKey(technicalName, params)

    const generateCodeAndURLUsingGET = useGenerateCodeAndURLUsingGETHook()

    const queryFn: QueryFunction<Awaited<ReturnType<ReturnType<typeof useGenerateCodeAndURLUsingGETHook>>>> = ({ signal }) =>
        generateCodeAndURLUsingGET(technicalName, params, signal)

    return { queryKey, queryFn, enabled: !!technicalName, ...queryOptions }
}

export type GenerateCodeAndURLUsingGETQueryResult = NonNullable<Awaited<ReturnType<ReturnType<typeof useGenerateCodeAndURLUsingGETHook>>>>
export type GenerateCodeAndURLUsingGETQueryError = ErrorType<void>

/**
 * @summary generateCodeAndURL
 */
export const useGenerateCodeAndURLUsingGET = <
    TData = Awaited<ReturnType<ReturnType<typeof useGenerateCodeAndURLUsingGETHook>>>,
    TError = ErrorType<void>,
>(
    technicalName: string,
    params: GenerateCodeAndURLUsingGETParams,
    options?: { query?: UseQueryOptions<Awaited<ReturnType<ReturnType<typeof useGenerateCodeAndURLUsingGETHook>>>, TError, TData> },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
    const queryOptions = useGenerateCodeAndURLUsingGETQueryOptions(technicalName, params, options)

    const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

    query.queryKey = queryOptions.queryKey

    return query
}

/**
 * @summary getLastCode
 */
export const useGetLastCodeUsingGETHook = () => {
    const getLastCodeUsingGET = useCustomClient<CiCode>()

    return (technicalName: string, params?: GetLastCodeUsingGETParams, signal?: AbortSignal) => {
        return getLastCodeUsingGET({ url: `/citypes/getLastCode/${technicalName}`, method: 'get', params, signal })
    }
}

export const getGetLastCodeUsingGETQueryKey = (technicalName: string, params?: GetLastCodeUsingGETParams) =>
    [`/citypes/getLastCode/${technicalName}`, ...(params ? [params] : [])] as const

export const useGetLastCodeUsingGETQueryOptions = <
    TData = Awaited<ReturnType<ReturnType<typeof useGetLastCodeUsingGETHook>>>,
    TError = ErrorType<void>,
>(
    technicalName: string,
    params?: GetLastCodeUsingGETParams,
    options?: { query?: UseQueryOptions<Awaited<ReturnType<ReturnType<typeof useGetLastCodeUsingGETHook>>>, TError, TData> },
): UseQueryOptions<Awaited<ReturnType<ReturnType<typeof useGetLastCodeUsingGETHook>>>, TError, TData> & { queryKey: QueryKey } => {
    const { query: queryOptions } = options ?? {}

    const queryKey = queryOptions?.queryKey ?? getGetLastCodeUsingGETQueryKey(technicalName, params)

    const getLastCodeUsingGET = useGetLastCodeUsingGETHook()

    const queryFn: QueryFunction<Awaited<ReturnType<ReturnType<typeof useGetLastCodeUsingGETHook>>>> = ({ signal }) =>
        getLastCodeUsingGET(technicalName, params, signal)

    return { queryKey, queryFn, enabled: !!technicalName, ...queryOptions }
}

export type GetLastCodeUsingGETQueryResult = NonNullable<Awaited<ReturnType<ReturnType<typeof useGetLastCodeUsingGETHook>>>>
export type GetLastCodeUsingGETQueryError = ErrorType<void>

/**
 * @summary getLastCode
 */
export const useGetLastCodeUsingGET = <TData = Awaited<ReturnType<ReturnType<typeof useGetLastCodeUsingGETHook>>>, TError = ErrorType<void>>(
    technicalName: string,
    params?: GetLastCodeUsingGETParams,
    options?: { query?: UseQueryOptions<Awaited<ReturnType<ReturnType<typeof useGetLastCodeUsingGETHook>>>, TError, TData> },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
    const queryOptions = useGetLastCodeUsingGETQueryOptions(technicalName, params, options)

    const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

    query.queryKey = queryOptions.queryKey

    return query
}

/**
 * @summary listCiTypes
 */
export const useListCiTypesUsingGETHook = () => {
    const listCiTypesUsingGET = useCustomClient<CiTypePreviewList>()

    return (ciTypeFilterBody: BodyType<CiTypeFilterBody>, signal?: AbortSignal) => {
        return listCiTypesUsingGET({ url: `/citypes/list`, method: 'get', headers: { 'Content-Type': 'application/json' }, signal })
    }
}

export const getListCiTypesUsingGETQueryKey = (ciTypeFilterBody: CiTypeFilterBody) => [`/citypes/list`, ciTypeFilterBody] as const

export const useListCiTypesUsingGETQueryOptions = <
    TData = Awaited<ReturnType<ReturnType<typeof useListCiTypesUsingGETHook>>>,
    TError = ErrorType<void>,
>(
    ciTypeFilterBody: CiTypeFilterBody,
    options?: { query?: UseQueryOptions<Awaited<ReturnType<ReturnType<typeof useListCiTypesUsingGETHook>>>, TError, TData> },
): UseQueryOptions<Awaited<ReturnType<ReturnType<typeof useListCiTypesUsingGETHook>>>, TError, TData> & { queryKey: QueryKey } => {
    const { query: queryOptions } = options ?? {}

    const queryKey = queryOptions?.queryKey ?? getListCiTypesUsingGETQueryKey(ciTypeFilterBody)

    const listCiTypesUsingGET = useListCiTypesUsingGETHook()

    const queryFn: QueryFunction<Awaited<ReturnType<ReturnType<typeof useListCiTypesUsingGETHook>>>> = ({ signal }) =>
        listCiTypesUsingGET(ciTypeFilterBody, signal)

    return { queryKey, queryFn, ...queryOptions }
}

export type ListCiTypesUsingGETQueryResult = NonNullable<Awaited<ReturnType<ReturnType<typeof useListCiTypesUsingGETHook>>>>
export type ListCiTypesUsingGETQueryError = ErrorType<void>

/**
 * @summary listCiTypes
 */
export const useListCiTypesUsingGET = <TData = Awaited<ReturnType<ReturnType<typeof useListCiTypesUsingGETHook>>>, TError = ErrorType<void>>(
    ciTypeFilterBody: CiTypeFilterBody,
    options?: { query?: UseQueryOptions<Awaited<ReturnType<ReturnType<typeof useListCiTypesUsingGETHook>>>, TError, TData> },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
    const queryOptions = useListCiTypesUsingGETQueryOptions(ciTypeFilterBody, options)

    const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

    query.queryKey = queryOptions.queryKey

    return query
}

/**
 * @summary listCiTypes
 */
export const useListCiTypesUsingPOSTHook = () => {
    const listCiTypesUsingPOST = useCustomClient<CiTypePreviewList | void>()

    return (ciTypeFilterBody: BodyType<CiTypeFilterBody>) => {
        return listCiTypesUsingPOST({ url: `/citypes/list`, method: 'post', headers: { 'Content-Type': 'application/json' }, data: ciTypeFilterBody })
    }
}

export const useListCiTypesUsingPOSTMutationOptions = <TError = ErrorType<unknown>, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<ReturnType<typeof useListCiTypesUsingPOSTHook>>>,
        TError,
        { data: BodyType<CiTypeFilterBody> },
        TContext
    >
}): UseMutationOptions<
    Awaited<ReturnType<ReturnType<typeof useListCiTypesUsingPOSTHook>>>,
    TError,
    { data: BodyType<CiTypeFilterBody> },
    TContext
> => {
    const { mutation: mutationOptions } = options ?? {}

    const listCiTypesUsingPOST = useListCiTypesUsingPOSTHook()

    const mutationFn: MutationFunction<Awaited<ReturnType<ReturnType<typeof useListCiTypesUsingPOSTHook>>>, { data: BodyType<CiTypeFilterBody> }> = (
        props,
    ) => {
        const { data } = props ?? {}

        return listCiTypesUsingPOST(data)
    }

    return { mutationFn, ...mutationOptions }
}

export type ListCiTypesUsingPOSTMutationResult = NonNullable<Awaited<ReturnType<ReturnType<typeof useListCiTypesUsingPOSTHook>>>>
export type ListCiTypesUsingPOSTMutationBody = BodyType<CiTypeFilterBody>
export type ListCiTypesUsingPOSTMutationError = ErrorType<unknown>

/**
 * @summary listCiTypes
 */
export const useListCiTypesUsingPOST = <TError = ErrorType<unknown>, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<ReturnType<typeof useListCiTypesUsingPOSTHook>>>,
        TError,
        { data: BodyType<CiTypeFilterBody> },
        TContext
    >
}) => {
    const mutationOptions = useListCiTypesUsingPOSTMutationOptions(options)

    return useMutation(mutationOptions)
}

/**
 * @summary listTypes
 */
export const useListTypesUsingPOSTHook = () => {
    const listTypesUsingPOST = useCustomClient<CiTypesRelationshipTypesList | void>()

    return (typesFilter: BodyType<TypesFilter>) => {
        return listTypesUsingPOST({
            url: `/citypes/relationshiptypes/list`,
            method: 'post',
            headers: { 'Content-Type': 'application/json' },
            data: typesFilter,
        })
    }
}

export const useListTypesUsingPOSTMutationOptions = <TError = ErrorType<unknown>, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<ReturnType<typeof useListTypesUsingPOSTHook>>>,
        TError,
        { data: BodyType<TypesFilter> },
        TContext
    >
}): UseMutationOptions<Awaited<ReturnType<ReturnType<typeof useListTypesUsingPOSTHook>>>, TError, { data: BodyType<TypesFilter> }, TContext> => {
    const { mutation: mutationOptions } = options ?? {}

    const listTypesUsingPOST = useListTypesUsingPOSTHook()

    const mutationFn: MutationFunction<Awaited<ReturnType<ReturnType<typeof useListTypesUsingPOSTHook>>>, { data: BodyType<TypesFilter> }> = (
        props,
    ) => {
        const { data } = props ?? {}

        return listTypesUsingPOST(data)
    }

    return { mutationFn, ...mutationOptions }
}

export type ListTypesUsingPOSTMutationResult = NonNullable<Awaited<ReturnType<ReturnType<typeof useListTypesUsingPOSTHook>>>>
export type ListTypesUsingPOSTMutationBody = BodyType<TypesFilter>
export type ListTypesUsingPOSTMutationError = ErrorType<unknown>

/**
 * @summary listTypes
 */
export const useListTypesUsingPOST = <TError = ErrorType<unknown>, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<ReturnType<typeof useListTypesUsingPOSTHook>>>,
        TError,
        { data: BodyType<TypesFilter> },
        TContext
    >
}) => {
    const mutationOptions = useListTypesUsingPOSTMutationOptions(options)

    return useMutation(mutationOptions)
}

/**
 * @summary storeAdminEntity
 */
export const useStoreAdminEntityUsingPOST1Hook = () => {
    const storeAdminEntityUsingPOST1 = useCustomClient<void>()

    return (relationshipType: BodyType<RelationshipType>, params?: StoreAdminEntityUsingPOST1Params) => {
        return storeAdminEntityUsingPOST1({
            url: `/relationshiptypes/adminentity/store`,
            method: 'post',
            headers: { 'Content-Type': 'application/json' },
            data: relationshipType,
            params,
        })
    }
}

export const useStoreAdminEntityUsingPOST1MutationOptions = <TError = ErrorType<unknown>, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<ReturnType<typeof useStoreAdminEntityUsingPOST1Hook>>>,
        TError,
        { data: BodyType<RelationshipType>; params?: StoreAdminEntityUsingPOST1Params },
        TContext
    >
}): UseMutationOptions<
    Awaited<ReturnType<ReturnType<typeof useStoreAdminEntityUsingPOST1Hook>>>,
    TError,
    { data: BodyType<RelationshipType>; params?: StoreAdminEntityUsingPOST1Params },
    TContext
> => {
    const { mutation: mutationOptions } = options ?? {}

    const storeAdminEntityUsingPOST1 = useStoreAdminEntityUsingPOST1Hook()

    const mutationFn: MutationFunction<
        Awaited<ReturnType<ReturnType<typeof useStoreAdminEntityUsingPOST1Hook>>>,
        { data: BodyType<RelationshipType>; params?: StoreAdminEntityUsingPOST1Params }
    > = (props) => {
        const { data, params } = props ?? {}

        return storeAdminEntityUsingPOST1(data, params)
    }

    return { mutationFn, ...mutationOptions }
}

export type StoreAdminEntityUsingPOST1MutationResult = NonNullable<Awaited<ReturnType<ReturnType<typeof useStoreAdminEntityUsingPOST1Hook>>>>
export type StoreAdminEntityUsingPOST1MutationBody = BodyType<RelationshipType>
export type StoreAdminEntityUsingPOST1MutationError = ErrorType<unknown>

/**
 * @summary storeAdminEntity
 */
export const useStoreAdminEntityUsingPOST1 = <TError = ErrorType<unknown>, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<ReturnType<typeof useStoreAdminEntityUsingPOST1Hook>>>,
        TError,
        { data: BodyType<RelationshipType>; params?: StoreAdminEntityUsingPOST1Params },
        TContext
    >
}) => {
    const mutationOptions = useStoreAdminEntityUsingPOST1MutationOptions(options)

    return useMutation(mutationOptions)
}

/**
 * @summary listRelationshipTypes
 */
export const useListRelationshipTypesUsingGETHook = () => {
    const listRelationshipTypesUsingGET = useCustomClient<RelationshipTypePreviewList>()

    return (relationshipTypeFilterBody: BodyType<RelationshipTypeFilterBody>, signal?: AbortSignal) => {
        return listRelationshipTypesUsingGET({
            url: `/relationshiptypes/list`,
            method: 'get',
            headers: { 'Content-Type': 'application/json' },
            signal,
        })
    }
}

export const getListRelationshipTypesUsingGETQueryKey = (relationshipTypeFilterBody: RelationshipTypeFilterBody) =>
    [`/relationshiptypes/list`, relationshipTypeFilterBody] as const

export const useListRelationshipTypesUsingGETQueryOptions = <
    TData = Awaited<ReturnType<ReturnType<typeof useListRelationshipTypesUsingGETHook>>>,
    TError = ErrorType<void>,
>(
    relationshipTypeFilterBody: RelationshipTypeFilterBody,
    options?: { query?: UseQueryOptions<Awaited<ReturnType<ReturnType<typeof useListRelationshipTypesUsingGETHook>>>, TError, TData> },
): UseQueryOptions<Awaited<ReturnType<ReturnType<typeof useListRelationshipTypesUsingGETHook>>>, TError, TData> & { queryKey: QueryKey } => {
    const { query: queryOptions } = options ?? {}

    const queryKey = queryOptions?.queryKey ?? getListRelationshipTypesUsingGETQueryKey(relationshipTypeFilterBody)

    const listRelationshipTypesUsingGET = useListRelationshipTypesUsingGETHook()

    const queryFn: QueryFunction<Awaited<ReturnType<ReturnType<typeof useListRelationshipTypesUsingGETHook>>>> = ({ signal }) =>
        listRelationshipTypesUsingGET(relationshipTypeFilterBody, signal)

    return { queryKey, queryFn, ...queryOptions }
}

export type ListRelationshipTypesUsingGETQueryResult = NonNullable<Awaited<ReturnType<ReturnType<typeof useListRelationshipTypesUsingGETHook>>>>
export type ListRelationshipTypesUsingGETQueryError = ErrorType<void>

/**
 * @summary listRelationshipTypes
 */
export const useListRelationshipTypesUsingGET = <
    TData = Awaited<ReturnType<ReturnType<typeof useListRelationshipTypesUsingGETHook>>>,
    TError = ErrorType<void>,
>(
    relationshipTypeFilterBody: RelationshipTypeFilterBody,
    options?: { query?: UseQueryOptions<Awaited<ReturnType<ReturnType<typeof useListRelationshipTypesUsingGETHook>>>, TError, TData> },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
    const queryOptions = useListRelationshipTypesUsingGETQueryOptions(relationshipTypeFilterBody, options)

    const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

    query.queryKey = queryOptions.queryKey

    return query
}

/**
 * @summary listRelationshipTypes
 */
export const useListRelationshipTypesUsingPOSTHook = () => {
    const listRelationshipTypesUsingPOST = useCustomClient<RelationshipTypePreviewList | void>()

    return (relationshipTypeFilterBody: BodyType<RelationshipTypeFilterBody>) => {
        return listRelationshipTypesUsingPOST({
            url: `/relationshiptypes/list`,
            method: 'post',
            headers: { 'Content-Type': 'application/json' },
            data: relationshipTypeFilterBody,
        })
    }
}

export const useListRelationshipTypesUsingPOSTMutationOptions = <TError = ErrorType<unknown>, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<ReturnType<typeof useListRelationshipTypesUsingPOSTHook>>>,
        TError,
        { data: BodyType<RelationshipTypeFilterBody> },
        TContext
    >
}): UseMutationOptions<
    Awaited<ReturnType<ReturnType<typeof useListRelationshipTypesUsingPOSTHook>>>,
    TError,
    { data: BodyType<RelationshipTypeFilterBody> },
    TContext
> => {
    const { mutation: mutationOptions } = options ?? {}

    const listRelationshipTypesUsingPOST = useListRelationshipTypesUsingPOSTHook()

    const mutationFn: MutationFunction<
        Awaited<ReturnType<ReturnType<typeof useListRelationshipTypesUsingPOSTHook>>>,
        { data: BodyType<RelationshipTypeFilterBody> }
    > = (props) => {
        const { data } = props ?? {}

        return listRelationshipTypesUsingPOST(data)
    }

    return { mutationFn, ...mutationOptions }
}

export type ListRelationshipTypesUsingPOSTMutationResult = NonNullable<Awaited<ReturnType<ReturnType<typeof useListRelationshipTypesUsingPOSTHook>>>>
export type ListRelationshipTypesUsingPOSTMutationBody = BodyType<RelationshipTypeFilterBody>
export type ListRelationshipTypesUsingPOSTMutationError = ErrorType<unknown>

/**
 * @summary listRelationshipTypes
 */
export const useListRelationshipTypesUsingPOST = <TError = ErrorType<unknown>, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<ReturnType<typeof useListRelationshipTypesUsingPOSTHook>>>,
        TError,
        { data: BodyType<RelationshipTypeFilterBody> },
        TContext
    >
}) => {
    const mutationOptions = useListRelationshipTypesUsingPOSTMutationOptions(options)

    return useMutation(mutationOptions)
}

/**
 * @summary storeNewRelationshipType
 */
export const useStoreNewRelationshipTypeUsingPOSTHook = () => {
    const storeNewRelationshipTypeUsingPOST = useCustomClient<RelationshipType | void>()

    return (relationshipTypeBody: BodyType<RelationshipTypeBody>, params?: StoreNewRelationshipTypeUsingPOSTParams) => {
        return storeNewRelationshipTypeUsingPOST({
            url: `/relationshiptypes/relationshiptype/store`,
            method: 'post',
            headers: { 'Content-Type': 'application/json' },
            data: relationshipTypeBody,
            params,
        })
    }
}

export const useStoreNewRelationshipTypeUsingPOSTMutationOptions = <TError = ErrorType<unknown>, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<ReturnType<typeof useStoreNewRelationshipTypeUsingPOSTHook>>>,
        TError,
        { data: BodyType<RelationshipTypeBody>; params?: StoreNewRelationshipTypeUsingPOSTParams },
        TContext
    >
}): UseMutationOptions<
    Awaited<ReturnType<ReturnType<typeof useStoreNewRelationshipTypeUsingPOSTHook>>>,
    TError,
    { data: BodyType<RelationshipTypeBody>; params?: StoreNewRelationshipTypeUsingPOSTParams },
    TContext
> => {
    const { mutation: mutationOptions } = options ?? {}

    const storeNewRelationshipTypeUsingPOST = useStoreNewRelationshipTypeUsingPOSTHook()

    const mutationFn: MutationFunction<
        Awaited<ReturnType<ReturnType<typeof useStoreNewRelationshipTypeUsingPOSTHook>>>,
        { data: BodyType<RelationshipTypeBody>; params?: StoreNewRelationshipTypeUsingPOSTParams }
    > = (props) => {
        const { data, params } = props ?? {}

        return storeNewRelationshipTypeUsingPOST(data, params)
    }

    return { mutationFn, ...mutationOptions }
}

export type StoreNewRelationshipTypeUsingPOSTMutationResult = NonNullable<
    Awaited<ReturnType<ReturnType<typeof useStoreNewRelationshipTypeUsingPOSTHook>>>
>
export type StoreNewRelationshipTypeUsingPOSTMutationBody = BodyType<RelationshipTypeBody>
export type StoreNewRelationshipTypeUsingPOSTMutationError = ErrorType<unknown>

/**
 * @summary storeNewRelationshipType
 */
export const useStoreNewRelationshipTypeUsingPOST = <TError = ErrorType<unknown>, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<ReturnType<typeof useStoreNewRelationshipTypeUsingPOSTHook>>>,
        TError,
        { data: BodyType<RelationshipTypeBody>; params?: StoreNewRelationshipTypeUsingPOSTParams },
        TContext
    >
}) => {
    const mutationOptions = useStoreNewRelationshipTypeUsingPOSTMutationOptions(options)

    return useMutation(mutationOptions)
}

/**
 * @summary storeExistRelationshipType
 */
export const useStoreExistRelationshipTypeUsingPUTHook = () => {
    const storeExistRelationshipTypeUsingPUT = useCustomClient<RelationshipType | void>()

    return (relationshipTypeBody: BodyType<RelationshipTypeBody>, params?: StoreExistRelationshipTypeUsingPUTParams) => {
        return storeExistRelationshipTypeUsingPUT({
            url: `/relationshiptypes/relationshiptype/store`,
            method: 'put',
            headers: { 'Content-Type': 'application/json' },
            data: relationshipTypeBody,
            params,
        })
    }
}

export const useStoreExistRelationshipTypeUsingPUTMutationOptions = <TError = ErrorType<unknown>, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<ReturnType<typeof useStoreExistRelationshipTypeUsingPUTHook>>>,
        TError,
        { data: BodyType<RelationshipTypeBody>; params?: StoreExistRelationshipTypeUsingPUTParams },
        TContext
    >
}): UseMutationOptions<
    Awaited<ReturnType<ReturnType<typeof useStoreExistRelationshipTypeUsingPUTHook>>>,
    TError,
    { data: BodyType<RelationshipTypeBody>; params?: StoreExistRelationshipTypeUsingPUTParams },
    TContext
> => {
    const { mutation: mutationOptions } = options ?? {}

    const storeExistRelationshipTypeUsingPUT = useStoreExistRelationshipTypeUsingPUTHook()

    const mutationFn: MutationFunction<
        Awaited<ReturnType<ReturnType<typeof useStoreExistRelationshipTypeUsingPUTHook>>>,
        { data: BodyType<RelationshipTypeBody>; params?: StoreExistRelationshipTypeUsingPUTParams }
    > = (props) => {
        const { data, params } = props ?? {}

        return storeExistRelationshipTypeUsingPUT(data, params)
    }

    return { mutationFn, ...mutationOptions }
}

export type StoreExistRelationshipTypeUsingPUTMutationResult = NonNullable<
    Awaited<ReturnType<ReturnType<typeof useStoreExistRelationshipTypeUsingPUTHook>>>
>
export type StoreExistRelationshipTypeUsingPUTMutationBody = BodyType<RelationshipTypeBody>
export type StoreExistRelationshipTypeUsingPUTMutationError = ErrorType<unknown>

/**
 * @summary storeExistRelationshipType
 */
export const useStoreExistRelationshipTypeUsingPUT = <TError = ErrorType<unknown>, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<ReturnType<typeof useStoreExistRelationshipTypeUsingPUTHook>>>,
        TError,
        { data: BodyType<RelationshipTypeBody>; params?: StoreExistRelationshipTypeUsingPUTParams },
        TContext
    >
}) => {
    const mutationOptions = useStoreExistRelationshipTypeUsingPUTMutationOptions(options)

    return useMutation(mutationOptions)
}

/**
 * @summary validRelationshipType
 */
export const useValidRelationshipTypeUsingPUTHook = () => {
    const validRelationshipTypeUsingPUT = useCustomClient<void>()

    return (technicalName: string, params?: ValidRelationshipTypeUsingPUTParams) => {
        return validRelationshipTypeUsingPUT({ url: `/relationshiptypes/relationshiptype/valid/${technicalName}`, method: 'put', params })
    }
}

export const useValidRelationshipTypeUsingPUTMutationOptions = <TError = ErrorType<unknown>, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<ReturnType<typeof useValidRelationshipTypeUsingPUTHook>>>,
        TError,
        { technicalName: string; params?: ValidRelationshipTypeUsingPUTParams },
        TContext
    >
}): UseMutationOptions<
    Awaited<ReturnType<ReturnType<typeof useValidRelationshipTypeUsingPUTHook>>>,
    TError,
    { technicalName: string; params?: ValidRelationshipTypeUsingPUTParams },
    TContext
> => {
    const { mutation: mutationOptions } = options ?? {}

    const validRelationshipTypeUsingPUT = useValidRelationshipTypeUsingPUTHook()

    const mutationFn: MutationFunction<
        Awaited<ReturnType<ReturnType<typeof useValidRelationshipTypeUsingPUTHook>>>,
        { technicalName: string; params?: ValidRelationshipTypeUsingPUTParams }
    > = (props) => {
        const { technicalName, params } = props ?? {}

        return validRelationshipTypeUsingPUT(technicalName, params)
    }

    return { mutationFn, ...mutationOptions }
}

export type ValidRelationshipTypeUsingPUTMutationResult = NonNullable<Awaited<ReturnType<ReturnType<typeof useValidRelationshipTypeUsingPUTHook>>>>

export type ValidRelationshipTypeUsingPUTMutationError = ErrorType<unknown>

/**
 * @summary validRelationshipType
 */
export const useValidRelationshipTypeUsingPUT = <TError = ErrorType<unknown>, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<ReturnType<typeof useValidRelationshipTypeUsingPUTHook>>>,
        TError,
        { technicalName: string; params?: ValidRelationshipTypeUsingPUTParams },
        TContext
    >
}) => {
    const mutationOptions = useValidRelationshipTypeUsingPUTMutationOptions(options)

    return useMutation(mutationOptions)
}

/**
 * @summary unvalidRelationshipType
 */
export const useUnvalidRelationshipTypeUsingDELETEHook = () => {
    const unvalidRelationshipTypeUsingDELETE = useCustomClient<void>()

    return (technicalName: string, params?: UnvalidRelationshipTypeUsingDELETEParams) => {
        return unvalidRelationshipTypeUsingDELETE({ url: `/relationshiptypes/relationshiptype/valid/${technicalName}`, method: 'delete', params })
    }
}

export const useUnvalidRelationshipTypeUsingDELETEMutationOptions = <TError = ErrorType<unknown>, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<ReturnType<typeof useUnvalidRelationshipTypeUsingDELETEHook>>>,
        TError,
        { technicalName: string; params?: UnvalidRelationshipTypeUsingDELETEParams },
        TContext
    >
}): UseMutationOptions<
    Awaited<ReturnType<ReturnType<typeof useUnvalidRelationshipTypeUsingDELETEHook>>>,
    TError,
    { technicalName: string; params?: UnvalidRelationshipTypeUsingDELETEParams },
    TContext
> => {
    const { mutation: mutationOptions } = options ?? {}

    const unvalidRelationshipTypeUsingDELETE = useUnvalidRelationshipTypeUsingDELETEHook()

    const mutationFn: MutationFunction<
        Awaited<ReturnType<ReturnType<typeof useUnvalidRelationshipTypeUsingDELETEHook>>>,
        { technicalName: string; params?: UnvalidRelationshipTypeUsingDELETEParams }
    > = (props) => {
        const { technicalName, params } = props ?? {}

        return unvalidRelationshipTypeUsingDELETE(technicalName, params)
    }

    return { mutationFn, ...mutationOptions }
}

export type UnvalidRelationshipTypeUsingDELETEMutationResult = NonNullable<
    Awaited<ReturnType<ReturnType<typeof useUnvalidRelationshipTypeUsingDELETEHook>>>
>

export type UnvalidRelationshipTypeUsingDELETEMutationError = ErrorType<unknown>

/**
 * @summary unvalidRelationshipType
 */
export const useUnvalidRelationshipTypeUsingDELETE = <TError = ErrorType<unknown>, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<ReturnType<typeof useUnvalidRelationshipTypeUsingDELETEHook>>>,
        TError,
        { technicalName: string; params?: UnvalidRelationshipTypeUsingDELETEParams },
        TContext
    >
}) => {
    const mutationOptions = useUnvalidRelationshipTypeUsingDELETEMutationOptions(options)

    return useMutation(mutationOptions)
}

/**
 * @summary getRelationshipType
 */
export const useGetRelationshipTypeUsingGETHook = () => {
    const getRelationshipTypeUsingGET = useCustomClient<RelationshipType>()

    return (technicalName: string, signal?: AbortSignal) => {
        return getRelationshipTypeUsingGET({ url: `/relationshiptypes/relationshiptype/${technicalName}`, method: 'get', signal })
    }
}

export const getGetRelationshipTypeUsingGETQueryKey = (technicalName: string) => [`/relationshiptypes/relationshiptype/${technicalName}`] as const

export const useGetRelationshipTypeUsingGETQueryOptions = <
    TData = Awaited<ReturnType<ReturnType<typeof useGetRelationshipTypeUsingGETHook>>>,
    TError = ErrorType<void>,
>(
    technicalName: string,
    options?: { query?: UseQueryOptions<Awaited<ReturnType<ReturnType<typeof useGetRelationshipTypeUsingGETHook>>>, TError, TData> },
): UseQueryOptions<Awaited<ReturnType<ReturnType<typeof useGetRelationshipTypeUsingGETHook>>>, TError, TData> & { queryKey: QueryKey } => {
    const { query: queryOptions } = options ?? {}

    const queryKey = queryOptions?.queryKey ?? getGetRelationshipTypeUsingGETQueryKey(technicalName)

    const getRelationshipTypeUsingGET = useGetRelationshipTypeUsingGETHook()

    const queryFn: QueryFunction<Awaited<ReturnType<ReturnType<typeof useGetRelationshipTypeUsingGETHook>>>> = ({ signal }) =>
        getRelationshipTypeUsingGET(technicalName, signal)

    return { queryKey, queryFn, enabled: !!technicalName, ...queryOptions }
}

export type GetRelationshipTypeUsingGETQueryResult = NonNullable<Awaited<ReturnType<ReturnType<typeof useGetRelationshipTypeUsingGETHook>>>>
export type GetRelationshipTypeUsingGETQueryError = ErrorType<void>

/**
 * @summary getRelationshipType
 */
export const useGetRelationshipTypeUsingGET = <
    TData = Awaited<ReturnType<ReturnType<typeof useGetRelationshipTypeUsingGETHook>>>,
    TError = ErrorType<void>,
>(
    technicalName: string,
    options?: { query?: UseQueryOptions<Awaited<ReturnType<ReturnType<typeof useGetRelationshipTypeUsingGETHook>>>, TError, TData> },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
    const queryOptions = useGetRelationshipTypeUsingGETQueryOptions(technicalName, options)

    const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

    query.queryKey = queryOptions.queryKey

    return query
}

/**
 * @summary storeAttributeTextation
 */
export const useStoreAttributeTextationUsingPUT1Hook = () => {
    const storeAttributeTextationUsingPUT1 = useCustomClient<void>()

    return (technicalName: string, attTecName: string, attributeBody: BodyType<AttributeBody>, params?: StoreAttributeTextationUsingPUT1Params) => {
        return storeAttributeTextationUsingPUT1({
            url: `/relationshiptypes/relationshiptype/${technicalName}/attribute/${attTecName}`,
            method: 'put',
            headers: { 'Content-Type': 'application/json' },
            data: attributeBody,
            params,
        })
    }
}

export const useStoreAttributeTextationUsingPUT1MutationOptions = <TError = ErrorType<unknown>, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<ReturnType<typeof useStoreAttributeTextationUsingPUT1Hook>>>,
        TError,
        { technicalName: string; attTecName: string; data: BodyType<AttributeBody>; params?: StoreAttributeTextationUsingPUT1Params },
        TContext
    >
}): UseMutationOptions<
    Awaited<ReturnType<ReturnType<typeof useStoreAttributeTextationUsingPUT1Hook>>>,
    TError,
    { technicalName: string; attTecName: string; data: BodyType<AttributeBody>; params?: StoreAttributeTextationUsingPUT1Params },
    TContext
> => {
    const { mutation: mutationOptions } = options ?? {}

    const storeAttributeTextationUsingPUT1 = useStoreAttributeTextationUsingPUT1Hook()

    const mutationFn: MutationFunction<
        Awaited<ReturnType<ReturnType<typeof useStoreAttributeTextationUsingPUT1Hook>>>,
        { technicalName: string; attTecName: string; data: BodyType<AttributeBody>; params?: StoreAttributeTextationUsingPUT1Params }
    > = (props) => {
        const { technicalName, attTecName, data, params } = props ?? {}

        return storeAttributeTextationUsingPUT1(technicalName, attTecName, data, params)
    }

    return { mutationFn, ...mutationOptions }
}

export type StoreAttributeTextationUsingPUT1MutationResult = NonNullable<
    Awaited<ReturnType<ReturnType<typeof useStoreAttributeTextationUsingPUT1Hook>>>
>
export type StoreAttributeTextationUsingPUT1MutationBody = BodyType<AttributeBody>
export type StoreAttributeTextationUsingPUT1MutationError = ErrorType<unknown>

/**
 * @summary storeAttributeTextation
 */
export const useStoreAttributeTextationUsingPUT1 = <TError = ErrorType<unknown>, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<ReturnType<typeof useStoreAttributeTextationUsingPUT1Hook>>>,
        TError,
        { technicalName: string; attTecName: string; data: BodyType<AttributeBody>; params?: StoreAttributeTextationUsingPUT1Params },
        TContext
    >
}) => {
    const mutationOptions = useStoreAttributeTextationUsingPUT1MutationOptions(options)

    return useMutation(mutationOptions)
}

/**
 * @summary deleteAttributeTextation
 */
export const useDeleteAttributeTextationUsingDELETE1Hook = () => {
    const deleteAttributeTextationUsingDELETE1 = useCustomClient<void>()

    return (technicalName: string, attTecName: string, params?: DeleteAttributeTextationUsingDELETE1Params) => {
        return deleteAttributeTextationUsingDELETE1({
            url: `/relationshiptypes/relationshiptype/${technicalName}/attribute/${attTecName}`,
            method: 'delete',
            params,
        })
    }
}

export const useDeleteAttributeTextationUsingDELETE1MutationOptions = <TError = ErrorType<unknown>, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<ReturnType<typeof useDeleteAttributeTextationUsingDELETE1Hook>>>,
        TError,
        { technicalName: string; attTecName: string; params?: DeleteAttributeTextationUsingDELETE1Params },
        TContext
    >
}): UseMutationOptions<
    Awaited<ReturnType<ReturnType<typeof useDeleteAttributeTextationUsingDELETE1Hook>>>,
    TError,
    { technicalName: string; attTecName: string; params?: DeleteAttributeTextationUsingDELETE1Params },
    TContext
> => {
    const { mutation: mutationOptions } = options ?? {}

    const deleteAttributeTextationUsingDELETE1 = useDeleteAttributeTextationUsingDELETE1Hook()

    const mutationFn: MutationFunction<
        Awaited<ReturnType<ReturnType<typeof useDeleteAttributeTextationUsingDELETE1Hook>>>,
        { technicalName: string; attTecName: string; params?: DeleteAttributeTextationUsingDELETE1Params }
    > = (props) => {
        const { technicalName, attTecName, params } = props ?? {}

        return deleteAttributeTextationUsingDELETE1(technicalName, attTecName, params)
    }

    return { mutationFn, ...mutationOptions }
}

export type DeleteAttributeTextationUsingDELETE1MutationResult = NonNullable<
    Awaited<ReturnType<ReturnType<typeof useDeleteAttributeTextationUsingDELETE1Hook>>>
>

export type DeleteAttributeTextationUsingDELETE1MutationError = ErrorType<unknown>

/**
 * @summary deleteAttributeTextation
 */
export const useDeleteAttributeTextationUsingDELETE1 = <TError = ErrorType<unknown>, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<ReturnType<typeof useDeleteAttributeTextationUsingDELETE1Hook>>>,
        TError,
        { technicalName: string; attTecName: string; params?: DeleteAttributeTextationUsingDELETE1Params },
        TContext
    >
}) => {
    const mutationOptions = useDeleteAttributeTextationUsingDELETE1MutationOptions(options)

    return useMutation(mutationOptions)
}

/**
 * @summary getAttributeOverrides
 */
export const useGetAttributeOverridesUsingGET1Hook = () => {
    const getAttributeOverridesUsingGET1 = useCustomClient<Attribute[]>()

    return (technicalName: string, signal?: AbortSignal) => {
        return getAttributeOverridesUsingGET1({
            url: `/relationshiptypes/relationshiptype/${technicalName}/attributeOverride`,
            method: 'get',
            signal,
        })
    }
}

export const getGetAttributeOverridesUsingGET1QueryKey = (technicalName: string) =>
    [`/relationshiptypes/relationshiptype/${technicalName}/attributeOverride`] as const

export const useGetAttributeOverridesUsingGET1QueryOptions = <
    TData = Awaited<ReturnType<ReturnType<typeof useGetAttributeOverridesUsingGET1Hook>>>,
    TError = ErrorType<void>,
>(
    technicalName: string,
    options?: { query?: UseQueryOptions<Awaited<ReturnType<ReturnType<typeof useGetAttributeOverridesUsingGET1Hook>>>, TError, TData> },
): UseQueryOptions<Awaited<ReturnType<ReturnType<typeof useGetAttributeOverridesUsingGET1Hook>>>, TError, TData> & { queryKey: QueryKey } => {
    const { query: queryOptions } = options ?? {}

    const queryKey = queryOptions?.queryKey ?? getGetAttributeOverridesUsingGET1QueryKey(technicalName)

    const getAttributeOverridesUsingGET1 = useGetAttributeOverridesUsingGET1Hook()

    const queryFn: QueryFunction<Awaited<ReturnType<ReturnType<typeof useGetAttributeOverridesUsingGET1Hook>>>> = ({ signal }) =>
        getAttributeOverridesUsingGET1(technicalName, signal)

    return { queryKey, queryFn, enabled: !!technicalName, ...queryOptions }
}

export type GetAttributeOverridesUsingGET1QueryResult = NonNullable<Awaited<ReturnType<ReturnType<typeof useGetAttributeOverridesUsingGET1Hook>>>>
export type GetAttributeOverridesUsingGET1QueryError = ErrorType<void>

/**
 * @summary getAttributeOverrides
 */
export const useGetAttributeOverridesUsingGET1 = <
    TData = Awaited<ReturnType<ReturnType<typeof useGetAttributeOverridesUsingGET1Hook>>>,
    TError = ErrorType<void>,
>(
    technicalName: string,
    options?: { query?: UseQueryOptions<Awaited<ReturnType<ReturnType<typeof useGetAttributeOverridesUsingGET1Hook>>>, TError, TData> },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
    const queryOptions = useGetAttributeOverridesUsingGET1QueryOptions(technicalName, options)

    const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

    query.queryKey = queryOptions.queryKey

    return query
}

/**
 * @summary listRelationshipTypes
 */
export const useListRelationshipTypesUsingGET1Hook = () => {
    const listRelationshipTypesUsingGET1 = useCustomClient<RightsTypeHolder[]>()

    return (params: ListRelationshipTypesUsingGET1Params, signal?: AbortSignal) => {
        return listRelationshipTypesUsingGET1({ url: `/rights/list`, method: 'get', params, signal })
    }
}

export const getListRelationshipTypesUsingGET1QueryKey = (params: ListRelationshipTypesUsingGET1Params) =>
    [`/rights/list`, ...(params ? [params] : [])] as const

export const useListRelationshipTypesUsingGET1QueryOptions = <
    TData = Awaited<ReturnType<ReturnType<typeof useListRelationshipTypesUsingGET1Hook>>>,
    TError = ErrorType<void>,
>(
    params: ListRelationshipTypesUsingGET1Params,
    options?: { query?: UseQueryOptions<Awaited<ReturnType<ReturnType<typeof useListRelationshipTypesUsingGET1Hook>>>, TError, TData> },
): UseQueryOptions<Awaited<ReturnType<ReturnType<typeof useListRelationshipTypesUsingGET1Hook>>>, TError, TData> & { queryKey: QueryKey } => {
    const { query: queryOptions } = options ?? {}

    const queryKey = queryOptions?.queryKey ?? getListRelationshipTypesUsingGET1QueryKey(params)

    const listRelationshipTypesUsingGET1 = useListRelationshipTypesUsingGET1Hook()

    const queryFn: QueryFunction<Awaited<ReturnType<ReturnType<typeof useListRelationshipTypesUsingGET1Hook>>>> = ({ signal }) =>
        listRelationshipTypesUsingGET1(params, signal)

    return { queryKey, queryFn, ...queryOptions }
}

export type ListRelationshipTypesUsingGET1QueryResult = NonNullable<Awaited<ReturnType<ReturnType<typeof useListRelationshipTypesUsingGET1Hook>>>>
export type ListRelationshipTypesUsingGET1QueryError = ErrorType<void>

/**
 * @summary listRelationshipTypes
 */
export const useListRelationshipTypesUsingGET1 = <
    TData = Awaited<ReturnType<ReturnType<typeof useListRelationshipTypesUsingGET1Hook>>>,
    TError = ErrorType<void>,
>(
    params: ListRelationshipTypesUsingGET1Params,
    options?: { query?: UseQueryOptions<Awaited<ReturnType<ReturnType<typeof useListRelationshipTypesUsingGET1Hook>>>, TError, TData> },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
    const queryOptions = useListRelationshipTypesUsingGET1QueryOptions(params, options)

    const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

    query.queryKey = queryOptions.queryKey

    return query
}
