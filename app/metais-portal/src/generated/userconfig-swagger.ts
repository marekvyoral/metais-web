/**
 * Generated by orval v6.16.0 üç∫
 * Do not edit manually.
 * MetaIS User Config
 * Api Documentation
 * OpenAPI spec version: 3.0-SNAPSHOT
 */
import { useQuery, useMutation } from '@tanstack/react-query'
import type { UseQueryOptions, UseMutationOptions, QueryFunction, MutationFunction, UseQueryResult, QueryKey } from '@tanstack/react-query'
import { useCustomClient } from '../hooks/use-custom-client'
import type { ErrorType, BodyType } from '../hooks/use-custom-client'
export type DeleteKvDataUsingDELETE200 = { [key: string]: any }

export type DeleteKvDataUsingDELETEParams = {
    'OAuth2Request.approved'?: boolean
    'OAuth2Request.authorities[0].authority'?: string
    'OAuth2Request.grantType'?: string
    'OAuth2Request.redirectUri'?: string
    'OAuth2Request.refresh'?: boolean
    'OAuth2Request.refreshTokenRequest.grantType'?: string
    'OAuth2Request.resourceIds'?: string[]
    'OAuth2Request.responseTypes'?: string[]
    authenticated?: boolean
    'authorities[0].authority'?: string
    clientOnly?: boolean
    credentials?: { [key: string]: any }
    details?: { [key: string]: any }
    name?: string
    principal?: { [key: string]: any }
    /**
     * shared
     */
    shared?: boolean
    'userAuthentication.authenticated'?: boolean
    'userAuthentication.authorities[0].authority'?: string
    'userAuthentication.credentials'?: { [key: string]: any }
    'userAuthentication.details'?: { [key: string]: any }
    'userAuthentication.principal'?: { [key: string]: any }
}

export type CreateKvPairUsingPUT200 = { [key: string]: any }

export type CreateKvPairUsingPUTParams = {
    'OAuth2Request.approved'?: boolean
    'OAuth2Request.authorities[0].authority'?: string
    'OAuth2Request.grantType'?: string
    'OAuth2Request.redirectUri'?: string
    'OAuth2Request.refresh'?: boolean
    'OAuth2Request.refreshTokenRequest.grantType'?: string
    'OAuth2Request.resourceIds'?: string[]
    'OAuth2Request.responseTypes'?: string[]
    authenticated?: boolean
    'authorities[0].authority'?: string
    clientOnly?: boolean
    credentials?: { [key: string]: any }
    details?: { [key: string]: any }
    name?: string
    principal?: { [key: string]: any }
    /**
     * shared
     */
    shared?: boolean
    'userAuthentication.authenticated'?: boolean
    'userAuthentication.authorities[0].authority'?: string
    'userAuthentication.credentials'?: { [key: string]: any }
    'userAuthentication.details'?: { [key: string]: any }
    'userAuthentication.principal'?: { [key: string]: any }
}

export type GetKvDataUsingGET200 = { [key: string]: any }

export type GetKvDataUsingGETParams = {
    'OAuth2Request.approved'?: boolean
    'OAuth2Request.authorities[0].authority'?: string
    'OAuth2Request.grantType'?: string
    'OAuth2Request.redirectUri'?: string
    'OAuth2Request.refresh'?: boolean
    'OAuth2Request.refreshTokenRequest.grantType'?: string
    'OAuth2Request.resourceIds'?: string[]
    'OAuth2Request.responseTypes'?: string[]
    authenticated?: boolean
    'authorities[0].authority'?: string
    clientOnly?: boolean
    credentials?: { [key: string]: any }
    details?: { [key: string]: any }
    name?: string
    /**
     * page
     */
    page?: number
    /**
     * perpage
     */
    perpage?: number
    principal?: { [key: string]: any }
    /**
     * shared
     */
    shared?: boolean
    'userAuthentication.authenticated'?: boolean
    'userAuthentication.authorities[0].authority'?: string
    'userAuthentication.credentials'?: { [key: string]: any }
    'userAuthentication.details'?: { [key: string]: any }
    'userAuthentication.principal'?: { [key: string]: any }
}

export type InsertDefaultColumnsUsingPOSTParams = {
    'OAuth2Request.approved'?: boolean
    'OAuth2Request.authorities[0].authority'?: string
    'OAuth2Request.grantType'?: string
    'OAuth2Request.redirectUri'?: string
    'OAuth2Request.refresh'?: boolean
    'OAuth2Request.refreshTokenRequest.grantType'?: string
    'OAuth2Request.resourceIds'?: string[]
    'OAuth2Request.responseTypes'?: string[]
    authenticated?: boolean
    'authorities[0].authority'?: string
    clientOnly?: boolean
    credentials?: { [key: string]: any }
    details?: { [key: string]: any }
    name?: string
    principal?: { [key: string]: any }
    'userAuthentication.authenticated'?: boolean
    'userAuthentication.authorities[0].authority'?: string
    'userAuthentication.credentials'?: { [key: string]: any }
    'userAuthentication.details'?: { [key: string]: any }
    'userAuthentication.principal'?: { [key: string]: any }
}

export type InsertUserColumnsUsingPOSTParams = {
    'OAuth2Request.approved'?: boolean
    'OAuth2Request.authorities[0].authority'?: string
    'OAuth2Request.grantType'?: string
    'OAuth2Request.redirectUri'?: string
    'OAuth2Request.refresh'?: boolean
    'OAuth2Request.refreshTokenRequest.grantType'?: string
    'OAuth2Request.resourceIds'?: string[]
    'OAuth2Request.responseTypes'?: string[]
    authenticated?: boolean
    'authorities[0].authority'?: string
    clientOnly?: boolean
    credentials?: { [key: string]: any }
    details?: { [key: string]: any }
    name?: string
    principal?: { [key: string]: any }
    'userAuthentication.authenticated'?: boolean
    'userAuthentication.authorities[0].authority'?: string
    'userAuthentication.credentials'?: { [key: string]: any }
    'userAuthentication.details'?: { [key: string]: any }
    'userAuthentication.principal'?: { [key: string]: any }
}

export type GetDefaultColumnsUsingGETParams = {
    'OAuth2Request.approved'?: boolean
    'OAuth2Request.authorities[0].authority'?: string
    'OAuth2Request.grantType'?: string
    'OAuth2Request.redirectUri'?: string
    'OAuth2Request.refresh'?: boolean
    'OAuth2Request.refreshTokenRequest.grantType'?: string
    'OAuth2Request.resourceIds'?: string[]
    'OAuth2Request.responseTypes'?: string[]
    authenticated?: boolean
    'authorities[0].authority'?: string
    clientOnly?: boolean
    credentials?: { [key: string]: any }
    details?: { [key: string]: any }
    name?: string
    principal?: { [key: string]: any }
    'userAuthentication.authenticated'?: boolean
    'userAuthentication.authorities[0].authority'?: string
    'userAuthentication.credentials'?: { [key: string]: any }
    'userAuthentication.details'?: { [key: string]: any }
    'userAuthentication.principal'?: { [key: string]: any }
}

export type ResetUserColumnsUsingDELETEParams = {
    'OAuth2Request.approved'?: boolean
    'OAuth2Request.authorities[0].authority'?: string
    'OAuth2Request.grantType'?: string
    'OAuth2Request.redirectUri'?: string
    'OAuth2Request.refresh'?: boolean
    'OAuth2Request.refreshTokenRequest.grantType'?: string
    'OAuth2Request.resourceIds'?: string[]
    'OAuth2Request.responseTypes'?: string[]
    authenticated?: boolean
    'authorities[0].authority'?: string
    clientOnly?: boolean
    credentials?: { [key: string]: any }
    details?: { [key: string]: any }
    name?: string
    principal?: { [key: string]: any }
    'userAuthentication.authenticated'?: boolean
    'userAuthentication.authorities[0].authority'?: string
    'userAuthentication.credentials'?: { [key: string]: any }
    'userAuthentication.details'?: { [key: string]: any }
    'userAuthentication.principal'?: { [key: string]: any }
}

export type GetUserColumnsUsingGETParams = {
    'OAuth2Request.approved'?: boolean
    'OAuth2Request.authorities[0].authority'?: string
    'OAuth2Request.grantType'?: string
    'OAuth2Request.redirectUri'?: string
    'OAuth2Request.refresh'?: boolean
    'OAuth2Request.refreshTokenRequest.grantType'?: string
    'OAuth2Request.resourceIds'?: string[]
    'OAuth2Request.responseTypes'?: string[]
    authenticated?: boolean
    'authorities[0].authority'?: string
    clientOnly?: boolean
    credentials?: { [key: string]: any }
    details?: { [key: string]: any }
    name?: string
    principal?: { [key: string]: any }
    'userAuthentication.authenticated'?: boolean
    'userAuthentication.authorities[0].authority'?: string
    'userAuthentication.credentials'?: { [key: string]: any }
    'userAuthentication.details'?: { [key: string]: any }
    'userAuthentication.principal'?: { [key: string]: any }
}

/**
 * favoriteCiType
 */
export type FavoriteCiTypeBody = FavoriteCiType

export interface FavoriteColumn {
    name?: string
    order?: number
}

export interface FavoriteCiType {
    attributes?: FavoriteColumn[]
    ciType?: string
    id?: number
    metaAttributes?: FavoriteColumn[]
}

type AwaitedInput<T> = PromiseLike<T> | T

type Awaited<O> = O extends AwaitedInput<infer T> ? T : never

/**
 * @summary getUserColumns
 */
export const useGetUserColumnsUsingGETHook = () => {
    const getUserColumnsUsingGET = useCustomClient<FavoriteCiType>()

    return (citype: string, params?: GetUserColumnsUsingGETParams, signal?: AbortSignal) => {
        return getUserColumnsUsingGET({ url: `/columns/citype/${citype}`, method: 'get', params, signal })
    }
}

export const getGetUserColumnsUsingGETQueryKey = (citype: string, params?: GetUserColumnsUsingGETParams) =>
    [`/columns/citype/${citype}`, ...(params ? [params] : [])] as const

export const useGetUserColumnsUsingGETQueryOptions = <
    TData = Awaited<ReturnType<ReturnType<typeof useGetUserColumnsUsingGETHook>>>,
    TError = ErrorType<void>,
>(
    citype: string,
    params?: GetUserColumnsUsingGETParams,
    options?: { query?: UseQueryOptions<Awaited<ReturnType<ReturnType<typeof useGetUserColumnsUsingGETHook>>>, TError, TData> },
): UseQueryOptions<Awaited<ReturnType<ReturnType<typeof useGetUserColumnsUsingGETHook>>>, TError, TData> & { queryKey: QueryKey } => {
    const { query: queryOptions } = options ?? {}

    const queryKey = queryOptions?.queryKey ?? getGetUserColumnsUsingGETQueryKey(citype, params)

    const getUserColumnsUsingGET = useGetUserColumnsUsingGETHook()

    const queryFn: QueryFunction<Awaited<ReturnType<ReturnType<typeof useGetUserColumnsUsingGETHook>>>> = ({ signal }) =>
        getUserColumnsUsingGET(citype, params, signal)

    return { queryKey, queryFn, enabled: !!citype, ...queryOptions }
}

export type GetUserColumnsUsingGETQueryResult = NonNullable<Awaited<ReturnType<ReturnType<typeof useGetUserColumnsUsingGETHook>>>>
export type GetUserColumnsUsingGETQueryError = ErrorType<void>

/**
 * @summary getUserColumns
 */
export const useGetUserColumnsUsingGET = <TData = Awaited<ReturnType<ReturnType<typeof useGetUserColumnsUsingGETHook>>>, TError = ErrorType<void>>(
    citype: string,
    params?: GetUserColumnsUsingGETParams,
    options?: { query?: UseQueryOptions<Awaited<ReturnType<ReturnType<typeof useGetUserColumnsUsingGETHook>>>, TError, TData> },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
    const queryOptions = useGetUserColumnsUsingGETQueryOptions(citype, params, options)

    const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

    query.queryKey = queryOptions.queryKey

    return query
}

/**
 * @summary resetUserColumns
 */
export const useResetUserColumnsUsingDELETEHook = () => {
    const resetUserColumnsUsingDELETE = useCustomClient<void>()

    return (citype: string, params?: ResetUserColumnsUsingDELETEParams) => {
        return resetUserColumnsUsingDELETE({ url: `/columns/citype/${citype}`, method: 'delete', params })
    }
}

export const useResetUserColumnsUsingDELETEMutationOptions = <TError = ErrorType<unknown>, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<ReturnType<typeof useResetUserColumnsUsingDELETEHook>>>,
        TError,
        { citype: string; params?: ResetUserColumnsUsingDELETEParams },
        TContext
    >
}): UseMutationOptions<
    Awaited<ReturnType<ReturnType<typeof useResetUserColumnsUsingDELETEHook>>>,
    TError,
    { citype: string; params?: ResetUserColumnsUsingDELETEParams },
    TContext
> => {
    const { mutation: mutationOptions } = options ?? {}

    const resetUserColumnsUsingDELETE = useResetUserColumnsUsingDELETEHook()

    const mutationFn: MutationFunction<
        Awaited<ReturnType<ReturnType<typeof useResetUserColumnsUsingDELETEHook>>>,
        { citype: string; params?: ResetUserColumnsUsingDELETEParams }
    > = (props) => {
        const { citype, params } = props ?? {}

        return resetUserColumnsUsingDELETE(citype, params)
    }

    return { mutationFn, ...mutationOptions }
}

export type ResetUserColumnsUsingDELETEMutationResult = NonNullable<Awaited<ReturnType<ReturnType<typeof useResetUserColumnsUsingDELETEHook>>>>

export type ResetUserColumnsUsingDELETEMutationError = ErrorType<unknown>

/**
 * @summary resetUserColumns
 */
export const useResetUserColumnsUsingDELETE = <TError = ErrorType<unknown>, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<ReturnType<typeof useResetUserColumnsUsingDELETEHook>>>,
        TError,
        { citype: string; params?: ResetUserColumnsUsingDELETEParams },
        TContext
    >
}) => {
    const mutationOptions = useResetUserColumnsUsingDELETEMutationOptions(options)

    return useMutation(mutationOptions)
}

/**
 * @summary getDefaultColumns
 */
export const useGetDefaultColumnsUsingGETHook = () => {
    const getDefaultColumnsUsingGET = useCustomClient<FavoriteCiType>()

    return (citype: string, params?: GetDefaultColumnsUsingGETParams, signal?: AbortSignal) => {
        return getDefaultColumnsUsingGET({ url: `/columns/citype/${citype}/default`, method: 'get', params, signal })
    }
}

export const getGetDefaultColumnsUsingGETQueryKey = (citype: string, params?: GetDefaultColumnsUsingGETParams) =>
    [`/columns/citype/${citype}/default`, ...(params ? [params] : [])] as const

export const useGetDefaultColumnsUsingGETQueryOptions = <
    TData = Awaited<ReturnType<ReturnType<typeof useGetDefaultColumnsUsingGETHook>>>,
    TError = ErrorType<void>,
>(
    citype: string,
    params?: GetDefaultColumnsUsingGETParams,
    options?: { query?: UseQueryOptions<Awaited<ReturnType<ReturnType<typeof useGetDefaultColumnsUsingGETHook>>>, TError, TData> },
): UseQueryOptions<Awaited<ReturnType<ReturnType<typeof useGetDefaultColumnsUsingGETHook>>>, TError, TData> & { queryKey: QueryKey } => {
    const { query: queryOptions } = options ?? {}

    const queryKey = queryOptions?.queryKey ?? getGetDefaultColumnsUsingGETQueryKey(citype, params)

    const getDefaultColumnsUsingGET = useGetDefaultColumnsUsingGETHook()

    const queryFn: QueryFunction<Awaited<ReturnType<ReturnType<typeof useGetDefaultColumnsUsingGETHook>>>> = ({ signal }) =>
        getDefaultColumnsUsingGET(citype, params, signal)

    return { queryKey, queryFn, enabled: !!citype, ...queryOptions }
}

export type GetDefaultColumnsUsingGETQueryResult = NonNullable<Awaited<ReturnType<ReturnType<typeof useGetDefaultColumnsUsingGETHook>>>>
export type GetDefaultColumnsUsingGETQueryError = ErrorType<void>

/**
 * @summary getDefaultColumns
 */
export const useGetDefaultColumnsUsingGET = <
    TData = Awaited<ReturnType<ReturnType<typeof useGetDefaultColumnsUsingGETHook>>>,
    TError = ErrorType<void>,
>(
    citype: string,
    params?: GetDefaultColumnsUsingGETParams,
    options?: { query?: UseQueryOptions<Awaited<ReturnType<ReturnType<typeof useGetDefaultColumnsUsingGETHook>>>, TError, TData> },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
    const queryOptions = useGetDefaultColumnsUsingGETQueryOptions(citype, params, options)

    const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

    query.queryKey = queryOptions.queryKey

    return query
}

/**
 * @summary insertUserColumns
 */
export const useInsertUserColumnsUsingPOSTHook = () => {
    const insertUserColumnsUsingPOST = useCustomClient<void>()

    return (favoriteCiTypeBody: BodyType<FavoriteCiTypeBody>, params?: InsertUserColumnsUsingPOSTParams) => {
        return insertUserColumnsUsingPOST({
            url: `/columns/store`,
            method: 'post',
            headers: { 'Content-Type': 'application/json' },
            data: favoriteCiTypeBody,
            params,
        })
    }
}

export const useInsertUserColumnsUsingPOSTMutationOptions = <TError = ErrorType<unknown>, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<ReturnType<typeof useInsertUserColumnsUsingPOSTHook>>>,
        TError,
        { data: BodyType<FavoriteCiTypeBody>; params?: InsertUserColumnsUsingPOSTParams },
        TContext
    >
}): UseMutationOptions<
    Awaited<ReturnType<ReturnType<typeof useInsertUserColumnsUsingPOSTHook>>>,
    TError,
    { data: BodyType<FavoriteCiTypeBody>; params?: InsertUserColumnsUsingPOSTParams },
    TContext
> => {
    const { mutation: mutationOptions } = options ?? {}

    const insertUserColumnsUsingPOST = useInsertUserColumnsUsingPOSTHook()

    const mutationFn: MutationFunction<
        Awaited<ReturnType<ReturnType<typeof useInsertUserColumnsUsingPOSTHook>>>,
        { data: BodyType<FavoriteCiTypeBody>; params?: InsertUserColumnsUsingPOSTParams }
    > = (props) => {
        const { data, params } = props ?? {}

        return insertUserColumnsUsingPOST(data, params)
    }

    return { mutationFn, ...mutationOptions }
}

export type InsertUserColumnsUsingPOSTMutationResult = NonNullable<Awaited<ReturnType<ReturnType<typeof useInsertUserColumnsUsingPOSTHook>>>>
export type InsertUserColumnsUsingPOSTMutationBody = BodyType<FavoriteCiTypeBody>
export type InsertUserColumnsUsingPOSTMutationError = ErrorType<unknown>

/**
 * @summary insertUserColumns
 */
export const useInsertUserColumnsUsingPOST = <TError = ErrorType<unknown>, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<ReturnType<typeof useInsertUserColumnsUsingPOSTHook>>>,
        TError,
        { data: BodyType<FavoriteCiTypeBody>; params?: InsertUserColumnsUsingPOSTParams },
        TContext
    >
}) => {
    const mutationOptions = useInsertUserColumnsUsingPOSTMutationOptions(options)

    return useMutation(mutationOptions)
}

/**
 * @summary insertDefaultColumns
 */
export const useInsertDefaultColumnsUsingPOSTHook = () => {
    const insertDefaultColumnsUsingPOST = useCustomClient<void>()

    return (favoriteCiTypeBody: BodyType<FavoriteCiTypeBody>, params?: InsertDefaultColumnsUsingPOSTParams) => {
        return insertDefaultColumnsUsingPOST({
            url: `/columns/store/default`,
            method: 'post',
            headers: { 'Content-Type': 'application/json' },
            data: favoriteCiTypeBody,
            params,
        })
    }
}

export const useInsertDefaultColumnsUsingPOSTMutationOptions = <TError = ErrorType<unknown>, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<ReturnType<typeof useInsertDefaultColumnsUsingPOSTHook>>>,
        TError,
        { data: BodyType<FavoriteCiTypeBody>; params?: InsertDefaultColumnsUsingPOSTParams },
        TContext
    >
}): UseMutationOptions<
    Awaited<ReturnType<ReturnType<typeof useInsertDefaultColumnsUsingPOSTHook>>>,
    TError,
    { data: BodyType<FavoriteCiTypeBody>; params?: InsertDefaultColumnsUsingPOSTParams },
    TContext
> => {
    const { mutation: mutationOptions } = options ?? {}

    const insertDefaultColumnsUsingPOST = useInsertDefaultColumnsUsingPOSTHook()

    const mutationFn: MutationFunction<
        Awaited<ReturnType<ReturnType<typeof useInsertDefaultColumnsUsingPOSTHook>>>,
        { data: BodyType<FavoriteCiTypeBody>; params?: InsertDefaultColumnsUsingPOSTParams }
    > = (props) => {
        const { data, params } = props ?? {}

        return insertDefaultColumnsUsingPOST(data, params)
    }

    return { mutationFn, ...mutationOptions }
}

export type InsertDefaultColumnsUsingPOSTMutationResult = NonNullable<Awaited<ReturnType<ReturnType<typeof useInsertDefaultColumnsUsingPOSTHook>>>>
export type InsertDefaultColumnsUsingPOSTMutationBody = BodyType<FavoriteCiTypeBody>
export type InsertDefaultColumnsUsingPOSTMutationError = ErrorType<unknown>

/**
 * @summary insertDefaultColumns
 */
export const useInsertDefaultColumnsUsingPOST = <TError = ErrorType<unknown>, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<ReturnType<typeof useInsertDefaultColumnsUsingPOSTHook>>>,
        TError,
        { data: BodyType<FavoriteCiTypeBody>; params?: InsertDefaultColumnsUsingPOSTParams },
        TContext
    >
}) => {
    const mutationOptions = useInsertDefaultColumnsUsingPOSTMutationOptions(options)

    return useMutation(mutationOptions)
}

/**
 * @summary liveness
 */
export const useLivenessUsingGETHook = () => {
    const livenessUsingGET = useCustomClient<void>()

    return (signal?: AbortSignal) => {
        return livenessUsingGET({ url: `/endpoints/health/liveness`, method: 'get', signal })
    }
}

export const getLivenessUsingGETQueryKey = () => [`/endpoints/health/liveness`] as const

export const useLivenessUsingGETQueryOptions = <
    TData = Awaited<ReturnType<ReturnType<typeof useLivenessUsingGETHook>>>,
    TError = ErrorType<unknown>,
>(options?: {
    query?: UseQueryOptions<Awaited<ReturnType<ReturnType<typeof useLivenessUsingGETHook>>>, TError, TData>
}): UseQueryOptions<Awaited<ReturnType<ReturnType<typeof useLivenessUsingGETHook>>>, TError, TData> & { queryKey: QueryKey } => {
    const { query: queryOptions } = options ?? {}

    const queryKey = queryOptions?.queryKey ?? getLivenessUsingGETQueryKey()

    const livenessUsingGET = useLivenessUsingGETHook()

    const queryFn: QueryFunction<Awaited<ReturnType<ReturnType<typeof useLivenessUsingGETHook>>>> = ({ signal }) => livenessUsingGET(signal)

    return { queryKey, queryFn, ...queryOptions }
}

export type LivenessUsingGETQueryResult = NonNullable<Awaited<ReturnType<ReturnType<typeof useLivenessUsingGETHook>>>>
export type LivenessUsingGETQueryError = ErrorType<unknown>

/**
 * @summary liveness
 */
export const useLivenessUsingGET = <TData = Awaited<ReturnType<ReturnType<typeof useLivenessUsingGETHook>>>, TError = ErrorType<unknown>>(options?: {
    query?: UseQueryOptions<Awaited<ReturnType<ReturnType<typeof useLivenessUsingGETHook>>>, TError, TData>
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
    const queryOptions = useLivenessUsingGETQueryOptions(options)

    const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

    query.queryKey = queryOptions.queryKey

    return query
}

/**
 * @summary readiness
 */
export const useReadinessUsingGETHook = () => {
    const readinessUsingGET = useCustomClient<void>()

    return (signal?: AbortSignal) => {
        return readinessUsingGET({ url: `/endpoints/health/readiness`, method: 'get', signal })
    }
}

export const getReadinessUsingGETQueryKey = () => [`/endpoints/health/readiness`] as const

export const useReadinessUsingGETQueryOptions = <
    TData = Awaited<ReturnType<ReturnType<typeof useReadinessUsingGETHook>>>,
    TError = ErrorType<unknown>,
>(options?: {
    query?: UseQueryOptions<Awaited<ReturnType<ReturnType<typeof useReadinessUsingGETHook>>>, TError, TData>
}): UseQueryOptions<Awaited<ReturnType<ReturnType<typeof useReadinessUsingGETHook>>>, TError, TData> & { queryKey: QueryKey } => {
    const { query: queryOptions } = options ?? {}

    const queryKey = queryOptions?.queryKey ?? getReadinessUsingGETQueryKey()

    const readinessUsingGET = useReadinessUsingGETHook()

    const queryFn: QueryFunction<Awaited<ReturnType<ReturnType<typeof useReadinessUsingGETHook>>>> = ({ signal }) => readinessUsingGET(signal)

    return { queryKey, queryFn, ...queryOptions }
}

export type ReadinessUsingGETQueryResult = NonNullable<Awaited<ReturnType<ReturnType<typeof useReadinessUsingGETHook>>>>
export type ReadinessUsingGETQueryError = ErrorType<unknown>

/**
 * @summary readiness
 */
export const useReadinessUsingGET = <
    TData = Awaited<ReturnType<ReturnType<typeof useReadinessUsingGETHook>>>,
    TError = ErrorType<unknown>,
>(options?: {
    query?: UseQueryOptions<Awaited<ReturnType<ReturnType<typeof useReadinessUsingGETHook>>>, TError, TData>
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
    const queryOptions = useReadinessUsingGETQueryOptions(options)

    const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

    query.queryKey = queryOptions.queryKey

    return query
}

/**
 * @summary getKvData
 */
export const useGetKvDataUsingGETHook = () => {
    const getKvDataUsingGET = useCustomClient<GetKvDataUsingGET200>()

    return (params?: GetKvDataUsingGETParams, signal?: AbortSignal) => {
        return getKvDataUsingGET({ url: `/kv/**`, method: 'get', params, signal })
    }
}

export const getGetKvDataUsingGETQueryKey = (params?: GetKvDataUsingGETParams) => [`/kv/**`, ...(params ? [params] : [])] as const

export const useGetKvDataUsingGETQueryOptions = <TData = Awaited<ReturnType<ReturnType<typeof useGetKvDataUsingGETHook>>>, TError = ErrorType<void>>(
    params?: GetKvDataUsingGETParams,
    options?: { query?: UseQueryOptions<Awaited<ReturnType<ReturnType<typeof useGetKvDataUsingGETHook>>>, TError, TData> },
): UseQueryOptions<Awaited<ReturnType<ReturnType<typeof useGetKvDataUsingGETHook>>>, TError, TData> & { queryKey: QueryKey } => {
    const { query: queryOptions } = options ?? {}

    const queryKey = queryOptions?.queryKey ?? getGetKvDataUsingGETQueryKey(params)

    const getKvDataUsingGET = useGetKvDataUsingGETHook()

    const queryFn: QueryFunction<Awaited<ReturnType<ReturnType<typeof useGetKvDataUsingGETHook>>>> = ({ signal }) => getKvDataUsingGET(params, signal)

    return { queryKey, queryFn, ...queryOptions }
}

export type GetKvDataUsingGETQueryResult = NonNullable<Awaited<ReturnType<ReturnType<typeof useGetKvDataUsingGETHook>>>>
export type GetKvDataUsingGETQueryError = ErrorType<void>

/**
 * @summary getKvData
 */
export const useGetKvDataUsingGET = <TData = Awaited<ReturnType<ReturnType<typeof useGetKvDataUsingGETHook>>>, TError = ErrorType<void>>(
    params?: GetKvDataUsingGETParams,
    options?: { query?: UseQueryOptions<Awaited<ReturnType<ReturnType<typeof useGetKvDataUsingGETHook>>>, TError, TData> },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
    const queryOptions = useGetKvDataUsingGETQueryOptions(params, options)

    const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

    query.queryKey = queryOptions.queryKey

    return query
}

/**
 * @summary createKvPair
 */
export const useCreateKvPairUsingPUTHook = () => {
    const createKvPairUsingPUT = useCustomClient<CreateKvPairUsingPUT200 | void>()

    return (createKvPairUsingPUTBody: BodyType<string>, params?: CreateKvPairUsingPUTParams) => {
        return createKvPairUsingPUT({
            url: `/kv/**`,
            method: 'put',
            headers: { 'Content-Type': 'application/json;charset=utf-8' },
            data: createKvPairUsingPUTBody,
            params,
        })
    }
}

export const useCreateKvPairUsingPUTMutationOptions = <TError = ErrorType<unknown>, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<ReturnType<typeof useCreateKvPairUsingPUTHook>>>,
        TError,
        { data: BodyType<string>; params?: CreateKvPairUsingPUTParams },
        TContext
    >
}): UseMutationOptions<
    Awaited<ReturnType<ReturnType<typeof useCreateKvPairUsingPUTHook>>>,
    TError,
    { data: BodyType<string>; params?: CreateKvPairUsingPUTParams },
    TContext
> => {
    const { mutation: mutationOptions } = options ?? {}

    const createKvPairUsingPUT = useCreateKvPairUsingPUTHook()

    const mutationFn: MutationFunction<
        Awaited<ReturnType<ReturnType<typeof useCreateKvPairUsingPUTHook>>>,
        { data: BodyType<string>; params?: CreateKvPairUsingPUTParams }
    > = (props) => {
        const { data, params } = props ?? {}

        return createKvPairUsingPUT(data, params)
    }

    return { mutationFn, ...mutationOptions }
}

export type CreateKvPairUsingPUTMutationResult = NonNullable<Awaited<ReturnType<ReturnType<typeof useCreateKvPairUsingPUTHook>>>>
export type CreateKvPairUsingPUTMutationBody = BodyType<string>
export type CreateKvPairUsingPUTMutationError = ErrorType<unknown>

/**
 * @summary createKvPair
 */
export const useCreateKvPairUsingPUT = <TError = ErrorType<unknown>, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<ReturnType<typeof useCreateKvPairUsingPUTHook>>>,
        TError,
        { data: BodyType<string>; params?: CreateKvPairUsingPUTParams },
        TContext
    >
}) => {
    const mutationOptions = useCreateKvPairUsingPUTMutationOptions(options)

    return useMutation(mutationOptions)
}

/**
 * @summary deleteKvData
 */
export const useDeleteKvDataUsingDELETEHook = () => {
    const deleteKvDataUsingDELETE = useCustomClient<DeleteKvDataUsingDELETE200 | void>()

    return (params?: DeleteKvDataUsingDELETEParams) => {
        return deleteKvDataUsingDELETE({ url: `/kv/**`, method: 'delete', params })
    }
}

export const useDeleteKvDataUsingDELETEMutationOptions = <TError = ErrorType<unknown>, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<ReturnType<typeof useDeleteKvDataUsingDELETEHook>>>,
        TError,
        { params?: DeleteKvDataUsingDELETEParams },
        TContext
    >
}): UseMutationOptions<
    Awaited<ReturnType<ReturnType<typeof useDeleteKvDataUsingDELETEHook>>>,
    TError,
    { params?: DeleteKvDataUsingDELETEParams },
    TContext
> => {
    const { mutation: mutationOptions } = options ?? {}

    const deleteKvDataUsingDELETE = useDeleteKvDataUsingDELETEHook()

    const mutationFn: MutationFunction<
        Awaited<ReturnType<ReturnType<typeof useDeleteKvDataUsingDELETEHook>>>,
        { params?: DeleteKvDataUsingDELETEParams }
    > = (props) => {
        const { params } = props ?? {}

        return deleteKvDataUsingDELETE(params)
    }

    return { mutationFn, ...mutationOptions }
}

export type DeleteKvDataUsingDELETEMutationResult = NonNullable<Awaited<ReturnType<ReturnType<typeof useDeleteKvDataUsingDELETEHook>>>>

export type DeleteKvDataUsingDELETEMutationError = ErrorType<unknown>

/**
 * @summary deleteKvData
 */
export const useDeleteKvDataUsingDELETE = <TError = ErrorType<unknown>, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<ReturnType<typeof useDeleteKvDataUsingDELETEHook>>>,
        TError,
        { params?: DeleteKvDataUsingDELETEParams },
        TContext
    >
}) => {
    const mutationOptions = useDeleteKvDataUsingDELETEMutationOptions(options)

    return useMutation(mutationOptions)
}
